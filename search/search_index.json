{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \u018fla! \u0130ndi h\u0259r 4 alt tap\u015f\u0131r\u0131\u011f\u0131 da ist\u0259diyin kimi \u2013 ba\u011fl\u0131 ba\u015fl\u0131q , riyazi formul , Python kodu , v\u0259 ingilis izah\u0131 il\u0259 ard\u0131c\u0131ll\u0131qla verir\u0259m. Task 1: Theoretical Foundation Mathematical Formulation: Projectile motion equations without air resistance and with launch height \\(h = 0\\) : \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Range is when \\(y(t) = 0\\) (excluding \\(t = 0\\) ): \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\Rightarrow R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Python Code: import numpy as np import matplotlib.pyplot as plt v0 = 20 # m/s g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = (v0**2) * np.sin(2 * angles_rad) / g plt.plot(angles_deg, ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs Angle of Projection') plt.grid(True) plt.show() Explanation: We derived the formula for projectile range as a function of angle. The range is maximum at 45\u00b0, and varies with \\(\\sin(2\\theta)\\) . Task 2: Analysis of the Range Mathematical Formulation: Range formula: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Increasing \\(v_0\\) increases range quadratically. Increasing \\(g\\) decreases range. Maximum at \\(\\theta = 45^\\circ\\) . Python Code: def compute_range(v0, g=9.81): angles = np.radians(np.linspace(0, 90, 500)) return (v0**2 * np.sin(2 * angles)) / g plt.figure(figsize=(8,5)) for v in [10, 20, 30]: plt.plot(np.linspace(0, 90, 500), compute_range(v), label=f'v0 = {v} m/s') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Effect of Initial Velocity on Range') plt.legend() plt.grid(True) plt.show() Explanation: This code compares how initial velocity affects projectile range. A higher \\(v_0\\) produces a much longer range. The angle for max range stays at 45\u00b0 regardless of \\(v_0\\) . Task 3: Practical Applications Mathematical Formulation: If projectile is launched from height \\(h > 0\\) : \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 + h \\] Solving \\(y(t) = 0\\) gives time of flight \\(t_f\\) , then: \\[ R = v_0 \\cos(\\theta) \\cdot t_f \\] No analytical formula; use numerical root-finding. Python Code: from scipy.optimize import fsolve def time_of_flight(theta, v0, h, g=9.81): def height_eq(t): return v0*np.sin(theta)*t - 0.5*g*t**2 + h t_guess = 2*v0*np.sin(theta)/g t_flight = fsolve(height_eq, t_guess)[0] return t_flight angles = np.radians(np.linspace(10, 80, 100)) v0 = 20 h = 5 ranges = [] for theta in angles: t_f = time_of_flight(theta, v0, h) R = v0 * np.cos(theta) * t_f ranges.append(R) plt.plot(np.degrees(angles), ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Range from Elevated Launch (h = 5 m)') plt.grid(True) plt.show() Explanation: We simulate launching from a height (e.g., a cliff). The range is longer than from ground-level. This models real-world scenarios like artillery or cliff jumps. Task 4: Implementation Mathematical Formulation: Simulate full 2D projectile path with: \\[ x(t) = v_0 \\cos(\\theta) t,\\quad y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Terminate when \\(y(t) \\leq 0\\) . Python Code: def simulate_trajectory(v0, theta_deg, g=9.81): theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y plt.figure(figsize=(8,5)) for angle in [30, 45, 60]: x, y = simulate_trajectory(20, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.title('Projectile Trajectories for Different Angles') plt.legend() plt.grid(True) plt.show() Explanation: This visualizes full projectile paths for multiple angles. It shows how different launch angles affect both the height and the range of the trajectory.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"\u018fla! \u0130ndi h\u0259r 4 alt tap\u015f\u0131r\u0131\u011f\u0131 da ist\u0259diyin kimi \u2013 ba\u011fl\u0131 ba\u015fl\u0131q , riyazi formul , Python kodu , v\u0259 ingilis izah\u0131 il\u0259 ard\u0131c\u0131ll\u0131qla verir\u0259m.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation","text":"Projectile motion equations without air resistance and with launch height \\(h = 0\\) : \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Range is when \\(y(t) = 0\\) (excluding \\(t = 0\\) ): \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\Rightarrow R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt v0 = 20 # m/s g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = (v0**2) * np.sin(2 * angles_rad) / g plt.plot(angles_deg, ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs Angle of Projection') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation","text":"We derived the formula for projectile range as a function of angle. The range is maximum at 45\u00b0, and varies with \\(\\sin(2\\theta)\\) .","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-2-analysis-of-the-range","text":"","title":"Task 2: Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation_1","text":"Range formula: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Increasing \\(v_0\\) increases range quadratically. Increasing \\(g\\) decreases range. Maximum at \\(\\theta = 45^\\circ\\) .","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code_1","text":"def compute_range(v0, g=9.81): angles = np.radians(np.linspace(0, 90, 500)) return (v0**2 * np.sin(2 * angles)) / g plt.figure(figsize=(8,5)) for v in [10, 20, 30]: plt.plot(np.linspace(0, 90, 500), compute_range(v), label=f'v0 = {v} m/s') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Effect of Initial Velocity on Range') plt.legend() plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation_1","text":"This code compares how initial velocity affects projectile range. A higher \\(v_0\\) produces a much longer range. The angle for max range stays at 45\u00b0 regardless of \\(v_0\\) .","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-3-practical-applications","text":"","title":"Task 3: Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation_2","text":"If projectile is launched from height \\(h > 0\\) : \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 + h \\] Solving \\(y(t) = 0\\) gives time of flight \\(t_f\\) , then: \\[ R = v_0 \\cos(\\theta) \\cdot t_f \\] No analytical formula; use numerical root-finding.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code_2","text":"from scipy.optimize import fsolve def time_of_flight(theta, v0, h, g=9.81): def height_eq(t): return v0*np.sin(theta)*t - 0.5*g*t**2 + h t_guess = 2*v0*np.sin(theta)/g t_flight = fsolve(height_eq, t_guess)[0] return t_flight angles = np.radians(np.linspace(10, 80, 100)) v0 = 20 h = 5 ranges = [] for theta in angles: t_f = time_of_flight(theta, v0, h) R = v0 * np.cos(theta) * t_f ranges.append(R) plt.plot(np.degrees(angles), ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Range from Elevated Launch (h = 5 m)') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation_2","text":"We simulate launching from a height (e.g., a cliff). The range is longer than from ground-level. This models real-world scenarios like artillery or cliff jumps.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation_3","text":"Simulate full 2D projectile path with: \\[ x(t) = v_0 \\cos(\\theta) t,\\quad y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Terminate when \\(y(t) \\leq 0\\) .","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code_3","text":"def simulate_trajectory(v0, theta_deg, g=9.81): theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y plt.figure(figsize=(8,5)) for angle in [30, 45, 60]: x, y = simulate_trajectory(20, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.title('Projectile Trajectories for Different Angles') plt.legend() plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation_3","text":"This visualizes full projectile paths for multiple angles. It shows how different launch angles affect both the height and the range of the trajectory.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Task 1: Theoretical Foundation Mathematical Formulation: The general equation for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles \\(\\theta \\ll 1\\) , we approximate \\(\\sin(\\theta) \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a second-order linear inhomogeneous differential equation, with resonance occurring when: \\[ \\omega \\approx \\omega_0 = \\sqrt{\\frac{g}{l}} \\] Python Code: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 l = 1.0 omega0 = np.sqrt(g / l) beta = 0.5 A = 1.2 omega = omega0 # Equation for small-angle approximation def pendulum(t, y): theta, v = y dtheta_dt = v dv_dt = -beta * v - omega0**2 * theta + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Solve t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.1, 0] sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Small-Angle Forced Damped Pendulum') plt.grid(True) plt.show() Explanation: We modeled a forced damped pendulum using the small-angle approximation. Resonance occurs when driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) . The code shows the resulting oscillations over time. Task 2: Analysis of Dynamics Mathematical Formulation: The full nonlinear equation: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Different behaviors emerge based on: \\(\\beta\\) : damping \\(A\\) : forcing amplitude \\(\\omega\\) : driving frequency This system can transition to chaos when \\(A\\) and \\(\\omega\\) are large enough. Python Code: def nonlinear_pendulum(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol2 = solve_ivp(nonlinear_pendulum, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol2.t, sol2.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Nonlinear Forced Damped Pendulum') plt.grid(True) plt.show() Explanation: Here we simulate the full nonlinear system. The motion can be quasiperiodic or chaotic depending on parameters. Nonlinearity introduces complex oscillations that don't appear in the small-angle model. Task 3: Practical Applications Mathematical Formulation: This model describes many real-world systems: Energy harvesters : convert periodic mechanical motion into electricity. Suspension bridges : under wind-induced oscillations. Driven RLC circuits : analogous second-order dynamics. The dynamics help design systems that avoid or exploit resonance. Python Code: def plot_multiple(beta_vals): plt.figure(figsize=(8,5)) for b in beta_vals: def dyn(t, y): return [y[1], -b * y[1] - omega0**2 * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(dyn, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Damping Effect on Pendulum Motion') plt.legend() plt.grid(True) plt.show() plot_multiple([0.2, 0.5, 1.0]) Explanation: Different damping values are simulated to show how energy dissipation impacts oscillations. Real systems like bridges must be designed to avoid excessive oscillations caused by resonance. Task 4: Implementation Mathematical Formulation: We simulate the nonlinear equation and create: Phase diagrams : \\(\\theta\\) vs \\(\\dot{\\theta}\\) Poincar\u00e9 sections : sample state at regular driving periods These reveal transitions from periodic to chaotic motion. Python Code: theta_vals = [] v_vals = [] times = [] def poincare(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol3 = solve_ivp(poincare, [0, 100], [0.1, 0], t_eval=np.linspace(0, 100, 5000)) for i, t in enumerate(sol3.t): if abs((omega * t) % (2*np.pi)) < 0.05: theta_vals.append(sol3.y[0][i]) v_vals.append(sol3.y[1][i]) times.append(t) plt.scatter(theta_vals, v_vals, s=5, c=times, cmap='viridis') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.title('Poincar\u00e9 Section of Forced Damped Pendulum') plt.colorbar(label='Time') plt.grid(True) plt.show() Explanation: This Poincar\u00e9 section reveals the structure of the pendulum\u2019s state sampled at regular driving intervals. If the system is chaotic, the points fill a region. If periodic, they form loops or discrete points.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation","text":"The general equation for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles \\(\\theta \\ll 1\\) , we approximate \\(\\sin(\\theta) \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a second-order linear inhomogeneous differential equation, with resonance occurring when: \\[ \\omega \\approx \\omega_0 = \\sqrt{\\frac{g}{l}} \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 l = 1.0 omega0 = np.sqrt(g / l) beta = 0.5 A = 1.2 omega = omega0 # Equation for small-angle approximation def pendulum(t, y): theta, v = y dtheta_dt = v dv_dt = -beta * v - omega0**2 * theta + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Solve t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.1, 0] sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Small-Angle Forced Damped Pendulum') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation","text":"We modeled a forced damped pendulum using the small-angle approximation. Resonance occurs when driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) . The code shows the resulting oscillations over time.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-2-analysis-of-dynamics","text":"","title":"Task 2: Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation_1","text":"The full nonlinear equation: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Different behaviors emerge based on: \\(\\beta\\) : damping \\(A\\) : forcing amplitude \\(\\omega\\) : driving frequency This system can transition to chaos when \\(A\\) and \\(\\omega\\) are large enough.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code_1","text":"def nonlinear_pendulum(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol2 = solve_ivp(nonlinear_pendulum, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol2.t, sol2.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Nonlinear Forced Damped Pendulum') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_1","text":"Here we simulate the full nonlinear system. The motion can be quasiperiodic or chaotic depending on parameters. Nonlinearity introduces complex oscillations that don't appear in the small-angle model.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-3-practical-applications","text":"","title":"Task 3: Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation_2","text":"This model describes many real-world systems: Energy harvesters : convert periodic mechanical motion into electricity. Suspension bridges : under wind-induced oscillations. Driven RLC circuits : analogous second-order dynamics. The dynamics help design systems that avoid or exploit resonance.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code_2","text":"def plot_multiple(beta_vals): plt.figure(figsize=(8,5)) for b in beta_vals: def dyn(t, y): return [y[1], -b * y[1] - omega0**2 * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(dyn, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Damping Effect on Pendulum Motion') plt.legend() plt.grid(True) plt.show() plot_multiple([0.2, 0.5, 1.0])","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_2","text":"Different damping values are simulated to show how energy dissipation impacts oscillations. Real systems like bridges must be designed to avoid excessive oscillations caused by resonance.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation_3","text":"We simulate the nonlinear equation and create: Phase diagrams : \\(\\theta\\) vs \\(\\dot{\\theta}\\) Poincar\u00e9 sections : sample state at regular driving periods These reveal transitions from periodic to chaotic motion.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code_3","text":"theta_vals = [] v_vals = [] times = [] def poincare(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol3 = solve_ivp(poincare, [0, 100], [0.1, 0], t_eval=np.linspace(0, 100, 5000)) for i, t in enumerate(sol3.t): if abs((omega * t) % (2*np.pi)) < 0.05: theta_vals.append(sol3.y[0][i]) v_vals.append(sol3.y[1][i]) times.append(t) plt.scatter(theta_vals, v_vals, s=5, c=times, cmap='viridis') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.title('Poincar\u00e9 Section of Forced Damped Pendulum') plt.colorbar(label='Time') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_4","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_3","text":"This Poincar\u00e9 section reveals the structure of the pendulum\u2019s state sampled at regular driving intervals. If the system is chaotic, the points fill a region. If periodic, they form loops or discrete points.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Task 1: Theoretical Foundation Mathematical Formulation: For a satellite in a circular orbit of radius \\(r\\) , the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for orbital speed \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] So we derive Kepler\u2019s Third Law : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Python Code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (from 7e6 m to 5e7 m) radii = np.linspace(7e6, 5e7, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to confirm linearity plt.plot(radii**3, periods**2, label=\"T\u00b2 vs r\u00b3\") plt.xlabel(\"Orbital Radius Cubed $r^3$ (m\u00b3)\") plt.ylabel(\"Orbital Period Squared $T^2$ (s\u00b2)\") plt.title(\"Kepler's Third Law Verification\") plt.grid(True) plt.legend() plt.show() Explanation: We used Newtonian mechanics to derive Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) . The simulation confirms this relationship for Earth-orbiting bodies. The linear graph of \\(T^2\\) vs \\(r^3\\) verifies the law for circular orbits. Task 2: Astronomical Implications Mathematical Formulation: From: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2} \\] This can be used to: Calculate the mass of the central object from satellite data. Estimate distances using observed periods (e.g., in binary stars). Python Code: # Example: Moon orbiting Earth T_moon = 27.32 * 24 * 3600 # seconds r_moon = 3.844e8 # meters # Calculate Earth\u2019s mass from Moon\u2019s orbit M_calc = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Calculated Earth Mass: {M_calc:.2e} kg\") print(f\"Actual Earth Mass: {M:.2e} kg\") Explanation: Using Kepler\u2019s Third Law, we can estimate Earth\u2019s mass from the Moon\u2019s orbital data. The calculated mass closely matches the known value, showcasing the law\u2019s practical power in astronomy. Task 3: Real-World Examples Mathematical Formulation: Using Kepler's Law: Planets farther from the Sun have longer periods. Ratio \\(T^2/r^3\\) is constant for all planets orbiting the same body. Python Code: # Data: Orbital radius (m), period (s) for some planets planet_data = { \"Earth\": (1.496e11, 365.25*24*3600), \"Mars\": (2.279e11, 687*24*3600), \"Jupiter\": (7.785e11, 4333*24*3600) } for planet, (r, T) in planet_data.items(): ratio = T**2 / r**3 print(f\"{planet}: T\u00b2/r\u00b3 = {ratio:.2e} s\u00b2/m\u00b3\") Explanation: We analyze Earth, Mars, and Jupiter to show \\(T^2/r^3\\) is approximately constant across planets. This confirms the universality of Kepler\u2019s Third Law in the Solar System. Task 4: Implementation Mathematical Formulation: Using: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] We simulate orbits for various radii, calculate \\(T\\) , and verify the power law. Python Code: # Visualize T vs r plt.figure(figsize=(8,5)) plt.plot(radii / 1e6, periods / 3600, color='purple') plt.xlabel(\"Orbital Radius (x10\u2076 m)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs Radius\") plt.grid(True) plt.show() Explanation: This visualization clearly shows the nonlinear dependence of orbital period on radius, consistent with \\(T \\propto r^{3/2}\\) . This helps predict how long satellites or planets take to orbit.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation","text":"For a satellite in a circular orbit of radius \\(r\\) , the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for orbital speed \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] So we derive Kepler\u2019s Third Law : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (from 7e6 m to 5e7 m) radii = np.linspace(7e6, 5e7, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to confirm linearity plt.plot(radii**3, periods**2, label=\"T\u00b2 vs r\u00b3\") plt.xlabel(\"Orbital Radius Cubed $r^3$ (m\u00b3)\") plt.ylabel(\"Orbital Period Squared $T^2$ (s\u00b2)\") plt.title(\"Kepler's Third Law Verification\") plt.grid(True) plt.legend() plt.show()","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation","text":"We used Newtonian mechanics to derive Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) . The simulation confirms this relationship for Earth-orbiting bodies. The linear graph of \\(T^2\\) vs \\(r^3\\) verifies the law for circular orbits.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-2-astronomical-implications","text":"","title":"Task 2: Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation_1","text":"From: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2} \\] This can be used to: Calculate the mass of the central object from satellite data. Estimate distances using observed periods (e.g., in binary stars).","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_1","text":"# Example: Moon orbiting Earth T_moon = 27.32 * 24 * 3600 # seconds r_moon = 3.844e8 # meters # Calculate Earth\u2019s mass from Moon\u2019s orbit M_calc = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Calculated Earth Mass: {M_calc:.2e} kg\") print(f\"Actual Earth Mass: {M:.2e} kg\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation_1","text":"Using Kepler\u2019s Third Law, we can estimate Earth\u2019s mass from the Moon\u2019s orbital data. The calculated mass closely matches the known value, showcasing the law\u2019s practical power in astronomy.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-3-real-world-examples","text":"","title":"Task 3: Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation_2","text":"Using Kepler's Law: Planets farther from the Sun have longer periods. Ratio \\(T^2/r^3\\) is constant for all planets orbiting the same body.","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_2","text":"# Data: Orbital radius (m), period (s) for some planets planet_data = { \"Earth\": (1.496e11, 365.25*24*3600), \"Mars\": (2.279e11, 687*24*3600), \"Jupiter\": (7.785e11, 4333*24*3600) } for planet, (r, T) in planet_data.items(): ratio = T**2 / r**3 print(f\"{planet}: T\u00b2/r\u00b3 = {ratio:.2e} s\u00b2/m\u00b3\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_3","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation_2","text":"We analyze Earth, Mars, and Jupiter to show \\(T^2/r^3\\) is approximately constant across planets. This confirms the universality of Kepler\u2019s Third Law in the Solar System.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation_3","text":"Using: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] We simulate orbits for various radii, calculate \\(T\\) , and verify the power law.","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_3","text":"# Visualize T vs r plt.figure(figsize=(8,5)) plt.plot(radii / 1e6, periods / 3600, color='purple') plt.xlabel(\"Orbital Radius (x10\u2076 m)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs Radius\") plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_4","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation_3","text":"This visualization clearly shows the nonlinear dependence of orbital period on radius, consistent with \\(T \\propto r^{3/2}\\) . This helps predict how long satellites or planets take to orbit.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Task 1: Theoretical Foundation Mathematical Formulation: First Cosmic Velocity \\(v_1\\) : orbital velocity near surface (circular orbit) $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity \\(v_2\\) : escape velocity (leave gravity without return) $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity \\(v_3\\) : velocity to escape from solar system starting from Earth\u2019s orbit $$ v_3 = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} $$ Python Code: import numpy as np # Gravitational constant G = 6.67430e-11 # Celestial bodies: mass (kg) and radius (m) bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.389e6}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7} } for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) print(f\"{body}:\\n v1 (orbital): {v1/1000:.2f} km/s\\n v2 (escape): {v2/1000:.2f} km/s\\n\") Explanation: We calculated the first and second cosmic velocities using Newtonian gravity. These correspond to orbital speed at surface and escape velocity. The results vary significantly by planetary mass and radius. Task 2: Analysis of Parameters Mathematical Formulation: Both \\(v_1\\) and \\(v_2\\) depend on: Gravitational constant \\(G\\) Mass of the body \\(M\\) Radius from center \\(R\\) \\[ v_2 = \\sqrt{2} \\cdot v_1 \\] Larger mass and smaller radius increase these velocities. Gas giants like Jupiter require much higher speeds to escape due to massive gravity. Python Code: import matplotlib.pyplot as plt # Generate masses and radii radii = np.linspace(1e6, 8e7, 1000) mass = 5.972e24 # Fix Earth mass v2_range = np.sqrt(2 * G * mass / radii) plt.plot(radii / 1e6, v2_range / 1000) plt.xlabel(\"Radius (x10\u2076 m)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.title(\"Escape Velocity vs Radius for Earth Mass\") plt.grid(True) plt.show() Explanation: This graph shows how escape velocity decreases with radius for a fixed mass. It\u2019s helpful for planning satellite launches or designing missions from orbital altitudes. Task 3: Practical Applications Mathematical Formulation: Satellites: need at least \\(v_1\\) Interplanetary probes: need \\(v_2\\) Interstellar missions: exceed \\(v_3\\) Example for Third Cosmic Velocity from Earth\u2019s orbit: \\[ v_3 = \\sqrt{2GM_{\\odot}/r} \\quad \\text{where } r = 1 \\text{ AU} \\] Python Code: # Sun parameters M_sun = 1.989e30 R_earth_orbit = 1.496e11 v_escape_sun = np.sqrt(2 * G * M_sun / R_earth_orbit) v_orbit_earth = np.sqrt(G * M_sun / R_earth_orbit) v3 = np.sqrt(v_escape_sun**2 + v_orbit_earth**2) print(f\"Third Cosmic Velocity from Earth Orbit: {v3/1000:.2f} km/s\") Explanation: Third cosmic velocity is the speed needed to escape the Sun\u2019s gravity from Earth\u2019s orbit. It's higher than the second velocity due to both Sun\u2019s gravity and Earth's orbital motion. This is critical for missions leaving the Solar System. Task 4: Implementation Python Code for Visualization: labels, v1s, v2s = [], [], [] for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) labels.append(body) v1s.append(v1 / 1000) v2s.append(v2 / 1000) x = np.arange(len(labels)) width = 0.35 plt.bar(x - width/2, v1s, width, label='v1 (Orbital)') plt.bar(x + width/2, v2s, width, label='v2 (Escape)') plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"First and Second Cosmic Velocities\") plt.legend() plt.grid(True, axis='y') plt.show() Explanation: This bar graph compares orbital and escape velocities of Earth, Mars, and Jupiter. It shows how much more velocity is needed to launch from massive planets, informing rocket design and fuel budgeting.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation","text":"First Cosmic Velocity \\(v_1\\) : orbital velocity near surface (circular orbit) $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity \\(v_2\\) : escape velocity (leave gravity without return) $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity \\(v_3\\) : velocity to escape from solar system starting from Earth\u2019s orbit $$ v_3 = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} $$","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code","text":"import numpy as np # Gravitational constant G = 6.67430e-11 # Celestial bodies: mass (kg) and radius (m) bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.389e6}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7} } for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) print(f\"{body}:\\n v1 (orbital): {v1/1000:.2f} km/s\\n v2 (escape): {v2/1000:.2f} km/s\\n\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation","text":"We calculated the first and second cosmic velocities using Newtonian gravity. These correspond to orbital speed at surface and escape velocity. The results vary significantly by planetary mass and radius.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-2-analysis-of-parameters","text":"","title":"Task 2: Analysis of Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation_1","text":"Both \\(v_1\\) and \\(v_2\\) depend on: Gravitational constant \\(G\\) Mass of the body \\(M\\) Radius from center \\(R\\) \\[ v_2 = \\sqrt{2} \\cdot v_1 \\] Larger mass and smaller radius increase these velocities. Gas giants like Jupiter require much higher speeds to escape due to massive gravity.","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code_1","text":"import matplotlib.pyplot as plt # Generate masses and radii radii = np.linspace(1e6, 8e7, 1000) mass = 5.972e24 # Fix Earth mass v2_range = np.sqrt(2 * G * mass / radii) plt.plot(radii / 1e6, v2_range / 1000) plt.xlabel(\"Radius (x10\u2076 m)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.title(\"Escape Velocity vs Radius for Earth Mass\") plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation_1","text":"This graph shows how escape velocity decreases with radius for a fixed mass. It\u2019s helpful for planning satellite launches or designing missions from orbital altitudes.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-3-practical-applications","text":"","title":"Task 3: Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation_2","text":"Satellites: need at least \\(v_1\\) Interplanetary probes: need \\(v_2\\) Interstellar missions: exceed \\(v_3\\) Example for Third Cosmic Velocity from Earth\u2019s orbit: \\[ v_3 = \\sqrt{2GM_{\\odot}/r} \\quad \\text{where } r = 1 \\text{ AU} \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code_2","text":"# Sun parameters M_sun = 1.989e30 R_earth_orbit = 1.496e11 v_escape_sun = np.sqrt(2 * G * M_sun / R_earth_orbit) v_orbit_earth = np.sqrt(G * M_sun / R_earth_orbit) v3 = np.sqrt(v_escape_sun**2 + v_orbit_earth**2) print(f\"Third Cosmic Velocity from Earth Orbit: {v3/1000:.2f} km/s\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation_2","text":"Third cosmic velocity is the speed needed to escape the Sun\u2019s gravity from Earth\u2019s orbit. It's higher than the second velocity due to both Sun\u2019s gravity and Earth's orbital motion. This is critical for missions leaving the Solar System.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-visualization","text":"labels, v1s, v2s = [], [], [] for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) labels.append(body) v1s.append(v1 / 1000) v2s.append(v2 / 1000) x = np.arange(len(labels)) width = 0.35 plt.bar(x - width/2, v1s, width, label='v1 (Orbital)') plt.bar(x + width/2, v2s, width, label='v2 (Escape)') plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"First and Second Cosmic Velocities\") plt.legend() plt.grid(True, axis='y') plt.show()","title":"Python Code for Visualization:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation_3","text":"This bar graph compares orbital and escape velocities of Earth, Mars, and Jupiter. It shows how much more velocity is needed to launch from massive planets, informing rocket design and fuel budgeting.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Task 1: Theoretical Foundation Mathematical Formulation: Newton\u2019s law of gravitation for a payload near Earth: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Using Newton\u2019s 2nd law: \\[ \\vec{a} = -\\frac{GM}{r^2} \\hat{r} \\] This leads to elliptical, parabolic, or hyperbolic orbits depending on total energy \\(E\\) : Elliptical : \\(E < 0\\) Parabolic : \\(E = 0\\) Hyperbolic : \\(E > 0\\) Where: \\[ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\] Python Code: import numpy as np def total_energy(v, r, M, m=1): G = 6.67430e-11 kinetic = 0.5 * m * v**2 potential = -G * M * m / r return kinetic + potential Explanation: We derive orbit type from the total mechanical energy of the payload. If energy is negative, it is bound (elliptical); if positive, it will escape Earth (hyperbolic). This helps mission planners decide if a payload re-enters or escapes. Task 2: Numerical Analysis of Trajectory Numerical Simulation: We simulate motion using Newton\u2019s gravitational law and solve with a numerical integrator (e.g., Euler/Verlet/RK4). Python Code (Runge-Kutta example): import matplotlib.pyplot as plt G = 6.67430e-11 M = 5.972e24 # Earth mass R_earth = 6.371e6 # Earth radius def acceleration(x, y): r = np.sqrt(x**2 + y**2) a = -G * M / r**3 return a * x, a * y def simulate_orbit(x0, y0, vx0, vy0, dt=1, steps=5000): x, y = x0, y0 vx, vy = vx0, vy0 traj_x, traj_y = [], [] for _ in range(steps): ax, ay = acceleration(x, y) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt traj_x.append(x) traj_y.append(y) if np.sqrt(x**2 + y**2) < R_earth: # collision break return traj_x, traj_y # Initial conditions: just above Earth x0, y0 = R_earth + 300000, 0 vx0, vy0 = 0, 7800 # orbital speed ~7.8 km/s x_traj, y_traj = simulate_orbit(x0, y0, vx0, vy0) plt.plot(x_traj, y_traj) circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(circle) plt.gca().set_aspect('equal') plt.title(\"Payload Trajectory near Earth\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid() plt.show() Explanation: This simulates the 2D motion of a payload under gravity. Depending on initial speed and direction, the result could be orbit, escape , or collision . Here, \\~7.8 km/s leads to near-circular orbit. Task 3: Practical Applications Real-World Scenarios: Elliptical Orbits \u2192 satellites Re-entry \u2192 de-orbit payload (e.g., ISS modules) Escape \u2192 deep space missions (Voyager, probes) We can analyze: Required velocity for return to Earth (below \\(v_1\\) ) Stability of orbit (around \\(v_1\\) ) Escape from Earth (above \\(v_2\\) ) Python Code to Test Multiple Speeds: speeds = [6500, 7800, 11200] # m/s: sub-orbital, orbital, escape colors = ['green', 'blue', 'red'] for v, color in zip(speeds, colors): x_t, y_t = simulate_orbit(x0, y0, 0, v) plt.plot(x_t, y_t, label=f\"{v/1000:.1f} km/s\", color=color) earth = plt.Circle((0, 0), R_earth, color='gray', alpha=0.4) plt.gca().add_artist(earth) plt.gca().set_aspect('equal') plt.legend() plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Different Initial Speeds \u2192 Different Trajectories\") plt.grid() plt.show() Explanation: The payload\u2019s trajectory type changes dramatically with initial velocity. This is key for space engineers \u2014 from orbital insertion to planetary escape planning. Task 4: Implementation & Visualization Summary Code with Classification: def classify_trajectory(v0, r0=R_earth + 300000): E = total_energy(v0, r0, M) if E < 0: return \"Elliptical\" elif E == 0: return \"Parabolic\" else: return \"Hyperbolic\" for v in [6500, 7800, 11200]: print(f\"v = {v} m/s \u2192 {classify_trajectory(v)}\") Explanation: This tool predicts trajectory type based on initial speed. It\u2019s a simple yet powerful simulation assistant for satellite or payload planning. Optional: 3D Simulation or Interactive Orbit Visualizer We can also extend this into a Jupyter Notebook interface or interactive GUI using tools like Plotly or VPython.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mathematical-formulation","text":"Newton\u2019s law of gravitation for a payload near Earth: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Using Newton\u2019s 2nd law: \\[ \\vec{a} = -\\frac{GM}{r^2} \\hat{r} \\] This leads to elliptical, parabolic, or hyperbolic orbits depending on total energy \\(E\\) : Elliptical : \\(E < 0\\) Parabolic : \\(E = 0\\) Hyperbolic : \\(E > 0\\) Where: \\[ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"import numpy as np def total_energy(v, r, M, m=1): G = 6.67430e-11 kinetic = 0.5 * m * v**2 potential = -G * M * m / r return kinetic + potential","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation","text":"We derive orbit type from the total mechanical energy of the payload. If energy is negative, it is bound (elliptical); if positive, it will escape Earth (hyperbolic). This helps mission planners decide if a payload re-enters or escapes.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-2-numerical-analysis-of-trajectory","text":"","title":"Task 2: Numerical Analysis of Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"We simulate motion using Newton\u2019s gravitational law and solve with a numerical integrator (e.g., Euler/Verlet/RK4).","title":"Numerical Simulation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-runge-kutta-example","text":"import matplotlib.pyplot as plt G = 6.67430e-11 M = 5.972e24 # Earth mass R_earth = 6.371e6 # Earth radius def acceleration(x, y): r = np.sqrt(x**2 + y**2) a = -G * M / r**3 return a * x, a * y def simulate_orbit(x0, y0, vx0, vy0, dt=1, steps=5000): x, y = x0, y0 vx, vy = vx0, vy0 traj_x, traj_y = [], [] for _ in range(steps): ax, ay = acceleration(x, y) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt traj_x.append(x) traj_y.append(y) if np.sqrt(x**2 + y**2) < R_earth: # collision break return traj_x, traj_y # Initial conditions: just above Earth x0, y0 = R_earth + 300000, 0 vx0, vy0 = 0, 7800 # orbital speed ~7.8 km/s x_traj, y_traj = simulate_orbit(x0, y0, vx0, vy0) plt.plot(x_traj, y_traj) circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(circle) plt.gca().set_aspect('equal') plt.title(\"Payload Trajectory near Earth\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid() plt.show()","title":"Python Code (Runge-Kutta example):"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation_1","text":"This simulates the 2D motion of a payload under gravity. Depending on initial speed and direction, the result could be orbit, escape , or collision . Here, \\~7.8 km/s leads to near-circular orbit.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-3-practical-applications","text":"","title":"Task 3: Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-scenarios","text":"Elliptical Orbits \u2192 satellites Re-entry \u2192 de-orbit payload (e.g., ISS modules) Escape \u2192 deep space missions (Voyager, probes) We can analyze: Required velocity for return to Earth (below \\(v_1\\) ) Stability of orbit (around \\(v_1\\) ) Escape from Earth (above \\(v_2\\) )","title":"Real-World Scenarios:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-to-test-multiple-speeds","text":"speeds = [6500, 7800, 11200] # m/s: sub-orbital, orbital, escape colors = ['green', 'blue', 'red'] for v, color in zip(speeds, colors): x_t, y_t = simulate_orbit(x0, y0, 0, v) plt.plot(x_t, y_t, label=f\"{v/1000:.1f} km/s\", color=color) earth = plt.Circle((0, 0), R_earth, color='gray', alpha=0.4) plt.gca().add_artist(earth) plt.gca().set_aspect('equal') plt.legend() plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Different Initial Speeds \u2192 Different Trajectories\") plt.grid() plt.show()","title":"Python Code to Test Multiple Speeds:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_3","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation_2","text":"The payload\u2019s trajectory type changes dramatically with initial velocity. This is key for space engineers \u2014 from orbital insertion to planetary escape planning.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-4-implementation-visualization","text":"","title":"Task 4: Implementation &amp; Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary-code-with-classification","text":"def classify_trajectory(v0, r0=R_earth + 300000): E = total_energy(v0, r0, M) if E < 0: return \"Elliptical\" elif E == 0: return \"Parabolic\" else: return \"Hyperbolic\" for v in [6500, 7800, 11200]: print(f\"v = {v} m/s \u2192 {classify_trajectory(v)}\")","title":"Summary Code with Classification:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_4","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation_3","text":"This tool predicts trajectory type based on initial speed. It\u2019s a simple yet powerful simulation assistant for satellite or payload planning.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#optional-3d-simulation-or-interactive-orbit-visualizer","text":"We can also extend this into a Jupyter Notebook interface or interactive GUI using tools like Plotly or VPython.","title":"Optional: 3D Simulation or Interactive Orbit Visualizer"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1: Interference Patterns on a Water Surface \ud83d\udd39 Mathematical Model The wave from a single point source is given by: \\[ \\eta(x, y, t) = A \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : Amplitude \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from the source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number \\(\\omega = 2\\pi f\\) : Angular frequency \\(\\phi\\) : Initial phase The total displacement from \\(N\\) sources becomes: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t + \\phi) \\] \ud83d\udd39 Python Code import numpy as np import matplotlib.pyplot as plt # Simulation Parameters A = 1.0 wavelength = 1.0 frequency = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t = 0 # Grid setup x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Regular Polygon: Square (4 vertices) n_sources = 4 radius = 2.0 angles = np.linspace(0, 2*np.pi, n_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Interference pattern Z = np.zeros_like(X) for x0, y0 in source_positions: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.sin(k * r - omega * t + phi) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.title('Interference Pattern from 4 Point Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-model","text":"The wave from a single point source is given by: \\[ \\eta(x, y, t) = A \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : Amplitude \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from the source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number \\(\\omega = 2\\pi f\\) : Angular frequency \\(\\phi\\) : Initial phase The total displacement from \\(N\\) sources becomes: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t + \\phi) \\]","title":"\ud83d\udd39 Mathematical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Simulation Parameters A = 1.0 wavelength = 1.0 frequency = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t = 0 # Grid setup x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Regular Polygon: Square (4 vertices) n_sources = 4 radius = 2.0 angles = np.linspace(0, 2*np.pi, n_sources, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Interference pattern Z = np.zeros_like(X) for x0, y0 in source_positions: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.sin(k * r - omega * t + phi) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.title('Interference Pattern from 4 Point Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show()","title":"\ud83d\udd39 Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Electromagnetism: Lorentz Force Simulation Problem 1: Simulating the Effects of the Lorentz Force Motivation The Lorentz force, given by F = q(E + v \u00d7 B) , governs the motion of charged particles in electromagnetic fields. This simulation explores particle trajectories in various field configurations, relevant to applications like particle accelerators, mass spectrometers, and plasma confinement devices. Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import solve_ivp ![alt text](image-5.png) ![alt text](image-6.png) class ChargedParticle: def __init__(self, q=1.6e-19, m=9.11e-31, v0=np.array([1e6, 0, 0])): self.q = q # Charge (C) self.m = m # Mass (kg) self.v0 = v0 # Initial velocity (m/s) def lorentz_force(self, t, state, E, B): \"\"\"Calculate the Lorentz force on the particle\"\"\" r, v = state[:3], state[3:] F = self.q * (E + np.cross(v, B)) return np.concatenate((v, F/self.m)) def simulate_trajectory(self, E, B, t_span=(0, 1e-8), dt=1e-11): \"\"\"Simulate particle motion using Runge-Kutta method\"\"\" initial_state = np.concatenate(([0, 0, 0], self.v0)) t_eval = np.arange(t_span[0], t_span[1], dt) sol = solve_ivp(self.lorentz_force, t_span, initial_state, args=(E, B), t_eval=t_eval, method='RK45') return sol.y[:3].T, sol.y[3:].T, sol.t @staticmethod def plot_trajectory_3d(pos, title): \"\"\"3D visualization of particle trajectory\"\"\" fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(pos[:,0], pos[:,1], pos[:,2], lw=2) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(title) plt.tight_layout() plt.show() @staticmethod def plot_trajectory_2d(pos, title): \"\"\"2D visualization of particle trajectory\"\"\" plt.figure(figsize=(8, 6)) plt.plot(pos[:,0], pos[:,1], lw=2) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title(title) plt.grid(True) plt.axis('equal') plt.tight_layout() plt.show() ![alt text](image-4.png) # Simulation parameters particle = ChargedParticle(q=1.6e-19, m=9.11e-31, v0=np.array([1e6, 0, 0])) Case 1: Uniform Magnetic Field (Cyclotron Motion) # Case 1: Uniform B field (cyclotron motion) B = np.array([0, 0, 1]) # 1 Tesla in z-direction E = np.array([0, 0, 0]) # No electric field pos, vel, t = particle.simulate_trajectory(E, B, t_span=(0, 5e-8)) # Calculate theoretical values omega = particle.q * np.linalg.norm(B) / particle.m # Cyclotron frequency r_L = np.linalg.norm(particle.v0[:2]) / omega # Larmor radius print(f\"Cyclotron frequency: {omega:.2e} rad/s\") print(f\"Larmor radius: {r_L:.2e} m\") particle.plot_trajectory_3d(pos, \"Particle Trajectory in Uniform B Field (3D)\") particle.plot_trajectory_2d(pos[:,:2], \"Particle Trajectory in Uniform B Field (XY Plane)\") Case 2: Combined Electric and Magnetic Fields (E \u2225 B) # Case 2: Parallel E and B fields B = np.array([0, 0, 1]) # 1 Tesla in z-direction E = np.array([0, 0, 1e5]) # 100 kV/m in z-direction pos, vel, t = particle.simulate_trajectory(E, B, t_span=(0, 5e-8)) particle.plot_trajectory_3d(pos, \"Particle Trajectory in Parallel E and B Fields (3D)\") particle.plot_trajectory_2d(pos[:,:2], \"Particle Trajectory in Parallel E and B Fields (XY Plane)\") Case 3: Crossed Electric and Magnetic Fields (E \u22a5 B) # Case 3: Crossed E and B fields (E \u22a5 B) B = np.array([0, 0, 1]) # 1 Tesla in z-direction E = np.array([0, 1e5, 0]) # 100 kV/m in y-direction pos, vel, t = particle.simulate_trajectory(E, B, t_span=(0, 1e-7)) # Calculate drift velocity v_drift = np.cross(E, B) / np.linalg.norm(B)**2 print(f\"E\u00d7B drift velocity: {v_drift} m/s\") particle.plot_trajectory_3d(pos, \"Particle Trajectory in Crossed E and B Fields (3D)\") particle.plot_trajectory_2d(pos[:,:2], \"Particle Trajectory in Crossed E and B Fields (XY Plane)\") Discussion of Results 1. Uniform Magnetic Field The particle executes circular motion in the plane perpendicular to B (xy-plane) The Larmor radius depends on particle velocity and magnetic field strength Applications: cyclotrons , mass spectrometers , and magnetic confinement in fusion devices 2. Parallel Electric and Magnetic Fields The particle follows a helical trajectory with increasing pitch The electric field accelerates the particle along the field direction (z-axis) Applications: particle accelerators , electron guns in CRTs 3. Crossed Electric and Magnetic Fields The particle exhibits E\u00d7B drift motion perpendicular to both fields The drift velocity matches the theoretical prediction v = E\u00d7B/B\u00b2 Applications: Hall effect thrusters , plasma confinement devices Extensions and Suggestions Non-uniform fields : Implement spatially varying B fields for more realistic simulations Relativistic effects : Modify equations for particles approaching light speed Multiple particles : Simulate particle beams or plasmas Time-varying fields : Study RF cavities or pulsed field devices Collisions : Add interaction terms for more realistic plasma simulations This simulation framework provides a foundation for exploring more complex electromagnetic systems relevant to both fundamental physics and engineering applications.","title":"Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulation","text":"","title":"Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, given by F = q(E + v \u00d7 B) , governs the motion of charged particles in electromagnetic fields. This simulation explores particle trajectories in various field configurations, relevant to applications like particle accelerators, mass spectrometers, and plasma confinement devices.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from scipy.integrate import solve_ivp ![alt text](image-5.png) ![alt text](image-6.png) class ChargedParticle: def __init__(self, q=1.6e-19, m=9.11e-31, v0=np.array([1e6, 0, 0])): self.q = q # Charge (C) self.m = m # Mass (kg) self.v0 = v0 # Initial velocity (m/s) def lorentz_force(self, t, state, E, B): \"\"\"Calculate the Lorentz force on the particle\"\"\" r, v = state[:3], state[3:] F = self.q * (E + np.cross(v, B)) return np.concatenate((v, F/self.m)) def simulate_trajectory(self, E, B, t_span=(0, 1e-8), dt=1e-11): \"\"\"Simulate particle motion using Runge-Kutta method\"\"\" initial_state = np.concatenate(([0, 0, 0], self.v0)) t_eval = np.arange(t_span[0], t_span[1], dt) sol = solve_ivp(self.lorentz_force, t_span, initial_state, args=(E, B), t_eval=t_eval, method='RK45') return sol.y[:3].T, sol.y[3:].T, sol.t @staticmethod def plot_trajectory_3d(pos, title): \"\"\"3D visualization of particle trajectory\"\"\" fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(pos[:,0], pos[:,1], pos[:,2], lw=2) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(title) plt.tight_layout() plt.show() @staticmethod def plot_trajectory_2d(pos, title): \"\"\"2D visualization of particle trajectory\"\"\" plt.figure(figsize=(8, 6)) plt.plot(pos[:,0], pos[:,1], lw=2) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title(title) plt.grid(True) plt.axis('equal') plt.tight_layout() plt.show() ![alt text](image-4.png) # Simulation parameters particle = ChargedParticle(q=1.6e-19, m=9.11e-31, v0=np.array([1e6, 0, 0]))","title":"Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-1-uniform-magnetic-field-cyclotron-motion","text":"# Case 1: Uniform B field (cyclotron motion) B = np.array([0, 0, 1]) # 1 Tesla in z-direction E = np.array([0, 0, 0]) # No electric field pos, vel, t = particle.simulate_trajectory(E, B, t_span=(0, 5e-8)) # Calculate theoretical values omega = particle.q * np.linalg.norm(B) / particle.m # Cyclotron frequency r_L = np.linalg.norm(particle.v0[:2]) / omega # Larmor radius print(f\"Cyclotron frequency: {omega:.2e} rad/s\") print(f\"Larmor radius: {r_L:.2e} m\") particle.plot_trajectory_3d(pos, \"Particle Trajectory in Uniform B Field (3D)\") particle.plot_trajectory_2d(pos[:,:2], \"Particle Trajectory in Uniform B Field (XY Plane)\")","title":"Case 1: Uniform Magnetic Field (Cyclotron Motion)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-2-combined-electric-and-magnetic-fields-e-b","text":"# Case 2: Parallel E and B fields B = np.array([0, 0, 1]) # 1 Tesla in z-direction E = np.array([0, 0, 1e5]) # 100 kV/m in z-direction pos, vel, t = particle.simulate_trajectory(E, B, t_span=(0, 5e-8)) particle.plot_trajectory_3d(pos, \"Particle Trajectory in Parallel E and B Fields (3D)\") particle.plot_trajectory_2d(pos[:,:2], \"Particle Trajectory in Parallel E and B Fields (XY Plane)\")","title":"Case 2: Combined Electric and Magnetic Fields (E \u2225 B)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-3-crossed-electric-and-magnetic-fields-e-b","text":"# Case 3: Crossed E and B fields (E \u22a5 B) B = np.array([0, 0, 1]) # 1 Tesla in z-direction E = np.array([0, 1e5, 0]) # 100 kV/m in y-direction pos, vel, t = particle.simulate_trajectory(E, B, t_span=(0, 1e-7)) # Calculate drift velocity v_drift = np.cross(E, B) / np.linalg.norm(B)**2 print(f\"E\u00d7B drift velocity: {v_drift} m/s\") particle.plot_trajectory_3d(pos, \"Particle Trajectory in Crossed E and B Fields (3D)\") particle.plot_trajectory_2d(pos[:,:2], \"Particle Trajectory in Crossed E and B Fields (XY Plane)\")","title":"Case 3: Crossed Electric and Magnetic Fields (E \u22a5 B)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#discussion-of-results","text":"","title":"Discussion of Results"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-uniform-magnetic-field","text":"The particle executes circular motion in the plane perpendicular to B (xy-plane) The Larmor radius depends on particle velocity and magnetic field strength Applications: cyclotrons , mass spectrometers , and magnetic confinement in fusion devices","title":"1. Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-parallel-electric-and-magnetic-fields","text":"The particle follows a helical trajectory with increasing pitch The electric field accelerates the particle along the field direction (z-axis) Applications: particle accelerators , electron guns in CRTs","title":"2. Parallel Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-crossed-electric-and-magnetic-fields","text":"The particle exhibits E\u00d7B drift motion perpendicular to both fields The drift velocity matches the theoretical prediction v = E\u00d7B/B\u00b2 Applications: Hall effect thrusters , plasma confinement devices","title":"3. Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions-and-suggestions","text":"Non-uniform fields : Implement spatially varying B fields for more realistic simulations Relativistic effects : Modify equations for particles approaching light speed Multiple particles : Simulate particle beams or plasmas Time-varying fields : Study RF cavities or pulsed field devices Collisions : Add interaction terms for more realistic plasma simulations This simulation framework provides a foundation for exploring more complex electromagnetic systems relevant to both fundamental physics and engineering applications.","title":"Extensions and Suggestions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1: Equivalent Resistance Using Graph Theory \ud83d\udd39 Mathematical and Algorithmic Foundation Electrical circuits can be modeled as weighted undirected graphs , where: Nodes = circuit junctions Edges = resistors (edge weights = resistance values) Goal : Find the equivalent resistance between two specified nodes (e.g., input and output terminals) by systematically reducing the graph. \u2705 Option 2: Advanced Task \u2013 Full Implementation \ud83e\udde0 Step-by-Step Strategy 1. Graph Representation Model the circuit as an undirected weighted graph using networkx . Each resistor is an edge with weight equal to its resistance. 2. Reduction Rules Series: If two nodes are connected by a single path (degree 2), collapse the series: $$ R_{\\text{eq}} = R_1 + R_2 $$ * Parallel: For nodes connected by multiple paths (same start and end), reduce using: $$ \\frac{1}{R_{\\text{eq}}} = \\sum \\frac{1}{R_i} $$ 3. Traversal and Simplification Use DFS or BFS to identify reduction opportunities. Repeatedly apply simplifications until only one equivalent edge remains between the start and end nodes. \ud83e\uddea Example Circuit Diagrams and Expected Behavior Example Type Description 1 Series Resistors 2\u03a9 and 3\u03a9 between A and B \u2192 Result: 5\u03a9 2 Parallel 2\u03a9 and 3\u03a9 in parallel between A and B \u2192 Result: \\(\\frac{1}{\\frac{1}{2} + \\frac{1}{3}} = 1.2\u03a9\\) 3 Mixed 2\u03a9 & 2\u03a9 in parallel, in series with 4\u03a9 \u2192 Result: 5\u03a9 \ud83d\udc0d Python Implementation import networkx as nx def combine_parallel_edges(G): for u, v in list(G.edges()): edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: total_inv = sum(1 / edge['resistance'] for edge in edges) R_eq = 1 / total_inv G.remove_edges_from([(u, v)] * len(edges)) G.add_edge(u, v, resistance=R_eq) def simplify_series_nodes(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree[node] == 2 and node not in ('A', 'B'): # Skip terminals neighbors = list(G.neighbors(node)) r1 = G[node][neighbors[0]]['resistance'] r2 = G[node][neighbors[1]]['resistance'] R_eq = r1 + r2 G.add_edge(neighbors[0], neighbors[1], resistance=R_eq) G.remove_node(node) changed = True break def calculate_equivalent_resistance(G, source, target): combine_parallel_edges(G) simplify_series_nodes(G) return G[source][target]['resistance'] if G.has_edge(source, target) else None # Example: Mixed circuit (Parallel + Series) G = nx.MultiGraph() G.add_edge('A', 'C', resistance=2) G.add_edge('A', 'C', resistance=2) G.add_edge('C', 'B', resistance=4) R_eq = calculate_equivalent_resistance(G, 'A', 'B') print(f\"Equivalent Resistance: {R_eq} \u03a9\") \ud83d\udcc8 Analysis of Algorithm Efficiency For sparse graphs (typical in circuits), performance is efficient: Series detection : \\(O(N)\\) Parallel merging : \\(O(E)\\) Can be improved using: Union-find data structures Kirchhoff\u2019s Laws and matrix reduction (for advanced cases) \ud83e\udde9 Conclusion This approach effectively models and reduces circuits using graph-based methods, automating what would otherwise be a manual and error-prone process for large circuits.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-and-algorithmic-foundation","text":"Electrical circuits can be modeled as weighted undirected graphs , where: Nodes = circuit junctions Edges = resistors (edge weights = resistance values) Goal : Find the equivalent resistance between two specified nodes (e.g., input and output terminals) by systematically reducing the graph.","title":"\ud83d\udd39 Mathematical and Algorithmic Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-advanced-task-full-implementation","text":"","title":"\u2705 Option 2: Advanced Task \u2013 Full Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-strategy","text":"","title":"\ud83e\udde0 Step-by-Step Strategy"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-graph-representation","text":"Model the circuit as an undirected weighted graph using networkx . Each resistor is an edge with weight equal to its resistance.","title":"1. Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-reduction-rules","text":"Series: If two nodes are connected by a single path (degree 2), collapse the series: $$ R_{\\text{eq}} = R_1 + R_2 $$ * Parallel: For nodes connected by multiple paths (same start and end), reduce using: $$ \\frac{1}{R_{\\text{eq}}} = \\sum \\frac{1}{R_i} $$","title":"2. Reduction Rules"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-traversal-and-simplification","text":"Use DFS or BFS to identify reduction opportunities. Repeatedly apply simplifications until only one equivalent edge remains between the start and end nodes.","title":"3. Traversal and Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-circuit-diagrams-and-expected-behavior","text":"Example Type Description 1 Series Resistors 2\u03a9 and 3\u03a9 between A and B \u2192 Result: 5\u03a9 2 Parallel 2\u03a9 and 3\u03a9 in parallel between A and B \u2192 Result: \\(\\frac{1}{\\frac{1}{2} + \\frac{1}{3}} = 1.2\u03a9\\) 3 Mixed 2\u03a9 & 2\u03a9 in parallel, in series with 4\u03a9 \u2192 Result: 5\u03a9","title":"\ud83e\uddea Example Circuit Diagrams and Expected Behavior"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"import networkx as nx def combine_parallel_edges(G): for u, v in list(G.edges()): edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: total_inv = sum(1 / edge['resistance'] for edge in edges) R_eq = 1 / total_inv G.remove_edges_from([(u, v)] * len(edges)) G.add_edge(u, v, resistance=R_eq) def simplify_series_nodes(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree[node] == 2 and node not in ('A', 'B'): # Skip terminals neighbors = list(G.neighbors(node)) r1 = G[node][neighbors[0]]['resistance'] r2 = G[node][neighbors[1]]['resistance'] R_eq = r1 + r2 G.add_edge(neighbors[0], neighbors[1], resistance=R_eq) G.remove_node(node) changed = True break def calculate_equivalent_resistance(G, source, target): combine_parallel_edges(G) simplify_series_nodes(G) return G[source][target]['resistance'] if G.has_edge(source, target) else None # Example: Mixed circuit (Parallel + Series) G = nx.MultiGraph() G.add_edge('A', 'C', resistance=2) G.add_edge('A', 'C', resistance=2) G.add_edge('C', 'B', resistance=4) R_eq = calculate_equivalent_resistance(G, 'A', 'B') print(f\"Equivalent Resistance: {R_eq} \u03a9\")","title":"\ud83d\udc0d Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#analysis-of-algorithm-efficiency","text":"For sparse graphs (typical in circuits), performance is efficient: Series detection : \\(O(N)\\) Parallel merging : \\(O(E)\\) Can be improved using: Union-find data structures Kirchhoff\u2019s Laws and matrix reduction (for advanced cases)","title":"\ud83d\udcc8 Analysis of Algorithm Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"This approach effectively models and reduces circuits using graph-based methods, automating what would otherwise be a manual and error-prone process for large circuits.","title":"\ud83e\udde9 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Central Limit Theorem Simulation 1. Problem Description Explore how the sampling distribution of the sample mean converges to a normal distribution for different population distributions and sample sizes. 2. Outline of the Approach Define several population distributions: Uniform Exponential Binomial For each distribution: Generate a large population dataset. Draw repeated samples of sizes 5, 10, 30, 50. Compute sample means for each sample. Plot histograms of the sampling distributions. Analyze: How shape affects convergence. Effect of variance on spread. 3. Example Python Notebook Implementation import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") # 1. Define population distributions population_size = 100000 populations = { 'Uniform(0, 1)': np.random.uniform(0, 1, population_size), 'Exponential(\u03bb=1)': np.random.exponential(scale=1, size=population_size), 'Binomial(n=10, p=0.5)': np.random.binomial(n=10, p=0.5, size=population_size) } # Sample sizes to test sample_sizes = [5, 10, 30, 50] n_samples = 1000 # Number of repeated samples # Function to perform sampling and compute sample means def sample_means(population, sample_size, n_samples): means = [] for _ in range(n_samples): sample = np.random.choice(population, sample_size, replace=False) means.append(np.mean(sample)) return np.array(means) # Plotting fig, axes = plt.subplots(len(populations), len(sample_sizes), figsize=(20, 12)) fig.suptitle(\"Sampling Distribution of Sample Means for Different Populations and Sample Sizes\", fontsize=16) for row_idx, (pop_name, population) in enumerate(populations.items()): pop_var = np.var(population) for col_idx, sample_size in enumerate(sample_sizes): means = sample_means(population, sample_size, n_samples) ax = axes[row_idx, col_idx] sns.histplot(means, bins=30, kde=True, ax=ax, color='skyblue') ax.set_title(f'{pop_name}\\nSample Size={sample_size}\\nPopulation Var={pop_var:.2f}') ax.set_xlabel('Sample Mean') ax.set_ylabel('Frequency') # Overlay normal distribution with same mean and variance of sample means sample_mean = np.mean(means) sample_std = np.std(means) x = np.linspace(min(means), max(means), 100) ax.plot(x, n_samples * (1/(sample_std * np.sqrt(2 * np.pi))) * np.exp(-(x - sample_mean)**2 / (2 * sample_std**2)), color='red', linestyle='--', label='Normal Approximation') ax.legend() plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() 4. What you will observe: For small sample sizes (5, 10) , sample means from skewed distributions (like exponential) look non-normal. As sample size increases (30, 50) , sample means approach a bell-shaped curve for all distributions. The spread (variance) of the sample means decreases as sample size increases, following the theoretical variance \\(\\sigma^2 / n\\) . 5. Discussion Points: The Central Limit Theorem works regardless of the original population distribution shape. Variance of sample means is smaller than population variance by a factor of sample size. This underpins confidence interval estimation, hypothesis testing, and quality control in practice. Understanding CLT helps justify normality assumptions in many real-world models even when data is not normal.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-simulation","text":"","title":"Central Limit Theorem Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-problem-description","text":"Explore how the sampling distribution of the sample mean converges to a normal distribution for different population distributions and sample sizes.","title":"1. Problem Description"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-outline-of-the-approach","text":"Define several population distributions: Uniform Exponential Binomial For each distribution: Generate a large population dataset. Draw repeated samples of sizes 5, 10, 30, 50. Compute sample means for each sample. Plot histograms of the sampling distributions. Analyze: How shape affects convergence. Effect of variance on spread.","title":"2. Outline of the Approach"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-example-python-notebook-implementation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") # 1. Define population distributions population_size = 100000 populations = { 'Uniform(0, 1)': np.random.uniform(0, 1, population_size), 'Exponential(\u03bb=1)': np.random.exponential(scale=1, size=population_size), 'Binomial(n=10, p=0.5)': np.random.binomial(n=10, p=0.5, size=population_size) } # Sample sizes to test sample_sizes = [5, 10, 30, 50] n_samples = 1000 # Number of repeated samples # Function to perform sampling and compute sample means def sample_means(population, sample_size, n_samples): means = [] for _ in range(n_samples): sample = np.random.choice(population, sample_size, replace=False) means.append(np.mean(sample)) return np.array(means) # Plotting fig, axes = plt.subplots(len(populations), len(sample_sizes), figsize=(20, 12)) fig.suptitle(\"Sampling Distribution of Sample Means for Different Populations and Sample Sizes\", fontsize=16) for row_idx, (pop_name, population) in enumerate(populations.items()): pop_var = np.var(population) for col_idx, sample_size in enumerate(sample_sizes): means = sample_means(population, sample_size, n_samples) ax = axes[row_idx, col_idx] sns.histplot(means, bins=30, kde=True, ax=ax, color='skyblue') ax.set_title(f'{pop_name}\\nSample Size={sample_size}\\nPopulation Var={pop_var:.2f}') ax.set_xlabel('Sample Mean') ax.set_ylabel('Frequency') # Overlay normal distribution with same mean and variance of sample means sample_mean = np.mean(means) sample_std = np.std(means) x = np.linspace(min(means), max(means), 100) ax.plot(x, n_samples * (1/(sample_std * np.sqrt(2 * np.pi))) * np.exp(-(x - sample_mean)**2 / (2 * sample_std**2)), color='red', linestyle='--', label='Normal Approximation') ax.legend() plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"3. Example Python Notebook Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-what-you-will-observe","text":"For small sample sizes (5, 10) , sample means from skewed distributions (like exponential) look non-normal. As sample size increases (30, 50) , sample means approach a bell-shaped curve for all distributions. The spread (variance) of the sample means decreases as sample size increases, following the theoretical variance \\(\\sigma^2 / n\\) .","title":"4. What you will observe:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-discussion-points","text":"The Central Limit Theorem works regardless of the original population distribution shape. Variance of sample means is smaller than population variance by a factor of sample size. This underpins confidence interval estimation, hypothesis testing, and quality control in practice. Understanding CLT helps justify normality assumptions in many real-world models even when data is not normal.","title":"5. Discussion Points:"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Part 1: Circle-based Monte Carlo estimation of \u03c0 Part 2: Buffon\u2019s Needle simulation estimation of \u03c0 Problem 2: Estimating \u03c0 Using Monte Carlo Methods Part 1: Circle-Based Monte Carlo Estimation Theoretical Foundation Imagine a square with side length 2 centered at the origin \\([-1,1] \\times [-1,1]\\) . Inside it is a circle of radius 1 centered at the origin. Area of square = \\(4\\) Area of circle = \\(\\pi \\times 1^2 = \\pi\\) The ratio of points inside the circle to total points inside the square should approximate the ratio of areas: $$ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} $$ Therefore: $$ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} $$ Simulation & Visualization import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): # Generate random points in the square [-1,1] x [-1,1] x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) # Calculate distance from origin dist = np.sqrt(x**2 + y**2) # Points inside the circle have distance <= 1 inside_circle = dist <= 1 count_inside = np.sum(inside_circle) # Estimate pi pi_estimate = 4 * count_inside / n_points return x, y, inside_circle, pi_estimate # Visualize with 1000 points n_points = 1000 x, y, inside_circle, pi_estimate = estimate_pi_circle(n_points) plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=5, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=5, label='Outside Circle') circle = plt.Circle((0,0), 1, color='black', fill=False, linewidth=2) plt.gca().add_artist(circle) plt.title(f'Estimation of \u03c0 using Monte Carlo\\nPoints: {n_points}, \u03c0 \u2248 {pi_estimate:.5f}') plt.legend() plt.axis('equal') plt.show() Analysis of Accuracy # Run for increasing sample sizes and plot convergence sample_sizes = np.logspace(2, 6, num=20, dtype=int) pi_estimates = [] for n in sample_sizes: _, _, _, pi_est = estimate_pi_circle(n) pi_estimates.append(pi_est) plt.figure(figsize=(8,5)) plt.plot(sample_sizes, pi_estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated \u03c0') plt.title('Convergence of Monte Carlo \u03c0 estimation (Circle method)') plt.legend() plt.show() Part 2: Buffon\u2019s Needle Problem Theoretical Foundation Buffon's Needle problem involves dropping a needle of length \\(L\\) onto a floor with parallel lines spaced a distance \\(d\\) apart, where \\(L \\leq d\\) . The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] By simulating needle drops and counting how often it crosses a line, we can estimate \u03c0 as: \\[ \\pi \\approx \\frac{2L \\times N}{d \\times \\text{Number of crossings}} \\] where \\(N\\) is the total number of needle drops. Simulation & Visualization def buffon_needle_simulation(n_drops, L=1.0, d=1.0): # Random distance from center of needle to closest line: uniform(0, d/2) distances = np.random.uniform(0, d/2, n_drops) # Random angle between needle and lines: uniform(0, pi/2) angles = np.random.uniform(0, np.pi/2, n_drops) # Needle crosses line if distance <= (L/2)*sin(angle) crosses = distances <= (L/2) * np.sin(angles) n_crosses = np.sum(crosses) # Estimate pi if n_crosses == 0: return None # Avoid division by zero pi_estimate = (2 * L * n_drops) / (d * n_crosses) return pi_estimate, distances, angles, crosses # Example visualization for 500 drops n_drops = 500 L = 1.0 d = 1.0 pi_estimate, distances, angles, crosses = buffon_needle_simulation(n_drops, L, d) print(f\"Estimated \u03c0 using Buffon's Needle: {pi_estimate:.5f}\") # Visualization: plot needle center distances vs angles, color by crossing plt.figure(figsize=(8,5)) plt.scatter(angles[crosses], distances[crosses], color='green', label='Crosses line') plt.scatter(angles[~crosses], distances[~crosses], color='orange', label='Does not cross') plt.axhline(L/2, color='black', linestyle='--', label='Max distance for crossing') plt.xlabel('Needle angle (radians)') plt.ylabel('Distance to closest line') plt.title(\"Buffon's Needle simulation\") plt.legend() plt.show() Analysis of Accuracy sample_sizes = np.logspace(2, 6, num=20, dtype=int) pi_estimates_buffon = [] for n in sample_sizes: result = buffon_needle_simulation(n, L, d) if result is not None: pi_est, _, _, _ = result pi_estimates_buffon.append(pi_est) else: pi_estimates_buffon.append(np.nan) plt.figure(figsize=(8,5)) plt.plot(sample_sizes, pi_estimates_buffon, marker='o', label=\"Buffon's Needle\") plt.axhline(np.pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel('Number of Needle Drops (log scale)') plt.ylabel('Estimated \u03c0') plt.title('Convergence of \u03c0 estimation (Buffon\\'s Needle)') plt.legend() plt.show() Summary of Deliverables Markdown document : Explain theory, formulas, and observations. Python code : Implementing both simulations and producing plots. Plots : Showing convergence of \u03c0 estimates and visualizations of random points and needles. Analysis : Discuss convergence rates, efficiency, and accuracy comparison between the two methods.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2-estimating-using-monte-carlo-methods","text":"","title":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-circle-based-monte-carlo-estimation","text":"","title":"Part 1: Circle-Based Monte Carlo Estimation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Imagine a square with side length 2 centered at the origin \\([-1,1] \\times [-1,1]\\) . Inside it is a circle of radius 1 centered at the origin. Area of square = \\(4\\) Area of circle = \\(\\pi \\times 1^2 = \\pi\\) The ratio of points inside the circle to total points inside the square should approximate the ratio of areas: $$ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} $$ Therefore: $$ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} $$","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-visualization","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): # Generate random points in the square [-1,1] x [-1,1] x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) # Calculate distance from origin dist = np.sqrt(x**2 + y**2) # Points inside the circle have distance <= 1 inside_circle = dist <= 1 count_inside = np.sum(inside_circle) # Estimate pi pi_estimate = 4 * count_inside / n_points return x, y, inside_circle, pi_estimate # Visualize with 1000 points n_points = 1000 x, y, inside_circle, pi_estimate = estimate_pi_circle(n_points) plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=5, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=5, label='Outside Circle') circle = plt.Circle((0,0), 1, color='black', fill=False, linewidth=2) plt.gca().add_artist(circle) plt.title(f'Estimation of \u03c0 using Monte Carlo\\nPoints: {n_points}, \u03c0 \u2248 {pi_estimate:.5f}') plt.legend() plt.axis('equal') plt.show()","title":"Simulation &amp; Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis-of-accuracy","text":"# Run for increasing sample sizes and plot convergence sample_sizes = np.logspace(2, 6, num=20, dtype=int) pi_estimates = [] for n in sample_sizes: _, _, _, pi_est = estimate_pi_circle(n) pi_estimates.append(pi_est) plt.figure(figsize=(8,5)) plt.plot(sample_sizes, pi_estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated \u03c0') plt.title('Convergence of Monte Carlo \u03c0 estimation (Circle method)') plt.legend() plt.show()","title":"Analysis of Accuracy"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-buffons-needle-problem","text":"","title":"Part 2: Buffon\u2019s Needle Problem"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon's Needle problem involves dropping a needle of length \\(L\\) onto a floor with parallel lines spaced a distance \\(d\\) apart, where \\(L \\leq d\\) . The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] By simulating needle drops and counting how often it crosses a line, we can estimate \u03c0 as: \\[ \\pi \\approx \\frac{2L \\times N}{d \\times \\text{Number of crossings}} \\] where \\(N\\) is the total number of needle drops.","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-visualization_1","text":"def buffon_needle_simulation(n_drops, L=1.0, d=1.0): # Random distance from center of needle to closest line: uniform(0, d/2) distances = np.random.uniform(0, d/2, n_drops) # Random angle between needle and lines: uniform(0, pi/2) angles = np.random.uniform(0, np.pi/2, n_drops) # Needle crosses line if distance <= (L/2)*sin(angle) crosses = distances <= (L/2) * np.sin(angles) n_crosses = np.sum(crosses) # Estimate pi if n_crosses == 0: return None # Avoid division by zero pi_estimate = (2 * L * n_drops) / (d * n_crosses) return pi_estimate, distances, angles, crosses # Example visualization for 500 drops n_drops = 500 L = 1.0 d = 1.0 pi_estimate, distances, angles, crosses = buffon_needle_simulation(n_drops, L, d) print(f\"Estimated \u03c0 using Buffon's Needle: {pi_estimate:.5f}\") # Visualization: plot needle center distances vs angles, color by crossing plt.figure(figsize=(8,5)) plt.scatter(angles[crosses], distances[crosses], color='green', label='Crosses line') plt.scatter(angles[~crosses], distances[~crosses], color='orange', label='Does not cross') plt.axhline(L/2, color='black', linestyle='--', label='Max distance for crossing') plt.xlabel('Needle angle (radians)') plt.ylabel('Distance to closest line') plt.title(\"Buffon's Needle simulation\") plt.legend() plt.show()","title":"Simulation &amp; Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis-of-accuracy_1","text":"sample_sizes = np.logspace(2, 6, num=20, dtype=int) pi_estimates_buffon = [] for n in sample_sizes: result = buffon_needle_simulation(n, L, d) if result is not None: pi_est, _, _, _ = result pi_estimates_buffon.append(pi_est) else: pi_estimates_buffon.append(np.nan) plt.figure(figsize=(8,5)) plt.plot(sample_sizes, pi_estimates_buffon, marker='o', label=\"Buffon's Needle\") plt.axhline(np.pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel('Number of Needle Drops (log scale)') plt.ylabel('Estimated \u03c0') plt.title('Convergence of \u03c0 estimation (Buffon\\'s Needle)') plt.legend() plt.show()","title":"Analysis of Accuracy"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_4","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary-of-deliverables","text":"Markdown document : Explain theory, formulas, and observations. Python code : Implementing both simulations and producing plots. Plots : Showing convergence of \u03c0 estimates and visualizations of random points and needles. Analysis : Discuss convergence rates, efficiency, and accuracy comparison between the two methods.","title":"Summary of Deliverables"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum 1. Materials and Setup String length (L): Measured from the suspension point to the center of the weight. Measuring tool resolution: e.g., ruler with 1 mm divisions \u2192 uncertainty in length \\(u_L = \\frac{1 \\text{ mm}}{2} = 0.5 \\text{ mm} = 0.0005 \\text{ m}\\) Timer: Stopwatch or smartphone with timing resolution (e.g., 0.01 s) Weight: Small object tied to string 2. Data Collection Displaced pendulum by less than 15\u00b0 to keep oscillations simple harmonic. Measured time for 10 oscillations, repeated 10 times. Trial Time for 10 oscillations (s) 1 20.05 2 20.00 3 20.10 4 20.02 5 20.04 6 20.07 7 20.01 8 20.03 9 20.06 10 20.05 import numpy as np import numpy as np Time measurements for 10 oscillations (seconds) times_10_osc = np.array([20.05, 20.00, 20.10, 20.02, 20.04, 20.07, 20.01, 20.03, 20.06, 20.05]) Pendulum length and its uncertainty (meters) L = 1.000 u_L = 0.0005 # 0.5 mm uncertainty Calculate mean time and standard deviation for 10 oscillations mean_time_10 = np.mean(times_10_osc) std_dev_10 = np.std(times_10_osc, ddof=1) Uncertainty in the mean time n = len(times_10_osc) u_mean_time_10 = std_dev_10 / np.sqrt(n) Calculate period for 1 oscillation and its uncertainty T = mean_time_10 / 10 u_T = u_mean_time_10 / 10 Calculate gravitational acceleration g g = (4 * np.pi 2 * L) / T 2 Partial derivatives for uncertainty propagation dg_dL = (4 * np.pi 2) / T 2 dg_dT = - (8 * np.pi 2 * L) / T 3 Calculate combined uncertainty in g u_g = np.sqrt((dg_dL * u_L) 2 + (dg_dT * u_T) 2) Print results print(f\"Mean time for 10 oscillations: {mean_time_10:.4f} \u00b1 {u_mean_time_10:.4f} s\") print(f\"Period for 1 oscillation: {T:.4f} \u00b1 {u_T:.4f} s\") print(f\"Calculated gravitational acceleration g: {g:.4f} \u00b1 {u_g:.4f} m/s\u00b2\") print(f\"Standard gravitational acceleration: 9.80665 m/s\u00b2\") 3. Calculations Step 1: Calculate mean time for 10 oscillations \\[ \\bar{T}_{10} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = \\frac{20.05 + 20.00 + \\cdots + 20.05}{10} = 20.043 \\text{ s} \\] Step 2: Calculate standard deviation \\[ s = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^n (T_{10,i} - \\bar{T}_{10})^2} \\approx 0.035 \\text{ s} \\] Step 3: Calculate uncertainty in the mean \\[ u_{T_{10}} = \\frac{s}{\\sqrt{n}} = \\frac{0.035}{\\sqrt{10}} = 0.011 \\text{ s} \\] Step 4: Calculate the period \\(T\\) for one oscillation \\[ T = \\frac{\\bar{T}_{10}}{10} = \\frac{20.043}{10} = 2.0043 \\text{ s} \\] Uncertainty: \\[ u_T = \\frac{u_{T_{10}}}{10} = \\frac{0.011}{10} = 0.0011 \\text{ s} \\] Step 5: Calculate gravitational acceleration \\(g\\) The formula relating period and \\(g\\) for small angles is: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\implies g = \\frac{4\\pi^2 L}{T^2} \\] Step 6: Calculate \\(g\\) value and propagate uncertainties Given \\(L = 1.000 \\text{ m}\\) \\(u_L = 0.0005 \\text{ m}\\) \\(T = 2.0043 \\text{ s}\\) \\(u_T = 0.0011 \\text{ s}\\) Calculate \\(g\\) : \\[ g = \\frac{4\\pi^2 \\times 1.000}{(2.0043)^2} \\approx 9.828 \\text{ m/s}^2 \\] Step 7: Uncertainty propagation for \\(g\\) Use partial derivatives: \\[ u_g = \\sqrt{\\left(\\frac{\\partial g}{\\partial L} u_L\\right)^2 + \\left(\\frac{\\partial g}{\\partial T} u_T\\right)^2} \\] Calculate derivatives: \\[ \\frac{\\partial g}{\\partial L} = \\frac{4\\pi^2}{T^2} \\] \\[ \\frac{\\partial g}{\\partial T} = -\\frac{8\\pi^2 L}{T^3} \\] Plug in values: \\[ \\frac{\\partial g}{\\partial L} = \\frac{4 \\times 9.8696}{(2.0043)^2} \\approx 9.80 \\text{ s}^{-2} \\] \\[ \\frac{\\partial g}{\\partial T} = -\\frac{8 \\times 9.8696 \\times 1.000}{(2.0043)^3} \\approx -19.61 \\text{ m/s}^3 \\] Calculate total uncertainty: \\[ u_g = \\sqrt{(9.80 \\times 0.0005)^2 + (-19.61 \\times 0.0011)^2} = \\sqrt{(0.0049)^2 + (-0.0216)^2} = \\sqrt{2.4 \\times 10^{-5} + 4.7 \\times 10^{-4}} \\approx 0.022 \\text{ m/s}^2 \\] 4. Results Summary Table Quantity Value Uncertainty Units Pendulum length \\(L\\) 1.000 0.0005 meters Mean time for 10 oscillations \\(\\bar{T}_{10}\\) 20.043 0.011 seconds Period \\(T\\) 2.0043 0.0011 seconds Calculated \\(g\\) 9.828 0.022 m/s\u00b2 Standard \\(g_0\\) 9.80665 (reference) m/s\u00b2 5. Discussion Sources of uncertainty: Length measurement resolution: The ruler's precision limits the exact value of \\(L\\) . The half-division rule is used to estimate this uncertainty. Timing uncertainty: Human reaction times and stopwatch precision cause variability in measuring oscillation times. Environmental factors: Air resistance, friction at the pivot, and angle of release (should be <15\u00b0) affect the period. Assumption of small angle: The formula assumes small oscillations to approximate simple harmonic motion; larger angles introduce systematic errors. Impact of uncertainties: Timing uncertainty has a larger effect on the uncertainty in \\(g\\) compared to length measurement, as shown by partial derivative magnitudes. Increasing the number of oscillations timed reduces relative timing uncertainty. Improving length measurement precision reduces overall uncertainty, but timing remains dominant. Comparison to standard \\(g\\) : The measured \\(g = 9.828 \\pm 0.022\\) m/s\u00b2 is close to the standard local gravitational acceleration \\(9.80665\\) m/s\u00b2. The difference may arise from local variations in gravity, experimental errors, or environmental influences.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials-and-setup","text":"String length (L): Measured from the suspension point to the center of the weight. Measuring tool resolution: e.g., ruler with 1 mm divisions \u2192 uncertainty in length \\(u_L = \\frac{1 \\text{ mm}}{2} = 0.5 \\text{ mm} = 0.0005 \\text{ m}\\) Timer: Stopwatch or smartphone with timing resolution (e.g., 0.01 s) Weight: Small object tied to string","title":"1. Materials and Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-data-collection","text":"Displaced pendulum by less than 15\u00b0 to keep oscillations simple harmonic. Measured time for 10 oscillations, repeated 10 times. Trial Time for 10 oscillations (s) 1 20.05 2 20.00 3 20.10 4 20.02 5 20.04 6 20.07 7 20.01 8 20.03 9 20.06 10 20.05 import numpy as np import numpy as np","title":"2. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#time-measurements-for-10-oscillations-seconds","text":"times_10_osc = np.array([20.05, 20.00, 20.10, 20.02, 20.04, 20.07, 20.01, 20.03, 20.06, 20.05])","title":"Time measurements for 10 oscillations (seconds)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#pendulum-length-and-its-uncertainty-meters","text":"L = 1.000 u_L = 0.0005 # 0.5 mm uncertainty","title":"Pendulum length and its uncertainty (meters)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-mean-time-and-standard-deviation-for-10-oscillations","text":"mean_time_10 = np.mean(times_10_osc) std_dev_10 = np.std(times_10_osc, ddof=1)","title":"Calculate mean time and standard deviation for 10 oscillations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-the-mean-time","text":"n = len(times_10_osc) u_mean_time_10 = std_dev_10 / np.sqrt(n)","title":"Uncertainty in the mean time"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-period-for-1-oscillation-and-its-uncertainty","text":"T = mean_time_10 / 10 u_T = u_mean_time_10 / 10","title":"Calculate period for 1 oscillation and its uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-gravitational-acceleration-g","text":"g = (4 * np.pi 2 * L) / T 2","title":"Calculate gravitational acceleration g"},{"location":"1%20Physics/7%20Measurements/Problem_1/#partial-derivatives-for-uncertainty-propagation","text":"dg_dL = (4 * np.pi 2) / T 2 dg_dT = - (8 * np.pi 2 * L) / T 3","title":"Partial derivatives for uncertainty propagation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-combined-uncertainty-in-g","text":"u_g = np.sqrt((dg_dL * u_L) 2 + (dg_dT * u_T) 2)","title":"Calculate combined uncertainty in g"},{"location":"1%20Physics/7%20Measurements/Problem_1/#print-results","text":"print(f\"Mean time for 10 oscillations: {mean_time_10:.4f} \u00b1 {u_mean_time_10:.4f} s\") print(f\"Period for 1 oscillation: {T:.4f} \u00b1 {u_T:.4f} s\") print(f\"Calculated gravitational acceleration g: {g:.4f} \u00b1 {u_g:.4f} m/s\u00b2\") print(f\"Standard gravitational acceleration: 9.80665 m/s\u00b2\")","title":"Print results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-calculations","text":"","title":"3. Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-1-calculate-mean-time-for-10-oscillations","text":"\\[ \\bar{T}_{10} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = \\frac{20.05 + 20.00 + \\cdots + 20.05}{10} = 20.043 \\text{ s} \\]","title":"Step 1: Calculate mean time for 10 oscillations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-2-calculate-standard-deviation","text":"\\[ s = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^n (T_{10,i} - \\bar{T}_{10})^2} \\approx 0.035 \\text{ s} \\]","title":"Step 2: Calculate standard deviation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-3-calculate-uncertainty-in-the-mean","text":"\\[ u_{T_{10}} = \\frac{s}{\\sqrt{n}} = \\frac{0.035}{\\sqrt{10}} = 0.011 \\text{ s} \\]","title":"Step 3: Calculate uncertainty in the mean"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-4-calculate-the-period-t-for-one-oscillation","text":"\\[ T = \\frac{\\bar{T}_{10}}{10} = \\frac{20.043}{10} = 2.0043 \\text{ s} \\] Uncertainty: \\[ u_T = \\frac{u_{T_{10}}}{10} = \\frac{0.011}{10} = 0.0011 \\text{ s} \\]","title":"Step 4: Calculate the period \\(T\\) for one oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-5-calculate-gravitational-acceleration-g","text":"The formula relating period and \\(g\\) for small angles is: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\implies g = \\frac{4\\pi^2 L}{T^2} \\]","title":"Step 5: Calculate gravitational acceleration \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-6-calculate-g-value-and-propagate-uncertainties","text":"Given \\(L = 1.000 \\text{ m}\\) \\(u_L = 0.0005 \\text{ m}\\) \\(T = 2.0043 \\text{ s}\\) \\(u_T = 0.0011 \\text{ s}\\) Calculate \\(g\\) : \\[ g = \\frac{4\\pi^2 \\times 1.000}{(2.0043)^2} \\approx 9.828 \\text{ m/s}^2 \\]","title":"Step 6: Calculate \\(g\\) value and propagate uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-7-uncertainty-propagation-for-g","text":"Use partial derivatives: \\[ u_g = \\sqrt{\\left(\\frac{\\partial g}{\\partial L} u_L\\right)^2 + \\left(\\frac{\\partial g}{\\partial T} u_T\\right)^2} \\] Calculate derivatives: \\[ \\frac{\\partial g}{\\partial L} = \\frac{4\\pi^2}{T^2} \\] \\[ \\frac{\\partial g}{\\partial T} = -\\frac{8\\pi^2 L}{T^3} \\] Plug in values: \\[ \\frac{\\partial g}{\\partial L} = \\frac{4 \\times 9.8696}{(2.0043)^2} \\approx 9.80 \\text{ s}^{-2} \\] \\[ \\frac{\\partial g}{\\partial T} = -\\frac{8 \\times 9.8696 \\times 1.000}{(2.0043)^3} \\approx -19.61 \\text{ m/s}^3 \\] Calculate total uncertainty: \\[ u_g = \\sqrt{(9.80 \\times 0.0005)^2 + (-19.61 \\times 0.0011)^2} = \\sqrt{(0.0049)^2 + (-0.0216)^2} = \\sqrt{2.4 \\times 10^{-5} + 4.7 \\times 10^{-4}} \\approx 0.022 \\text{ m/s}^2 \\]","title":"Step 7: Uncertainty propagation for \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-results-summary-table","text":"Quantity Value Uncertainty Units Pendulum length \\(L\\) 1.000 0.0005 meters Mean time for 10 oscillations \\(\\bar{T}_{10}\\) 20.043 0.011 seconds Period \\(T\\) 2.0043 0.0011 seconds Calculated \\(g\\) 9.828 0.022 m/s\u00b2 Standard \\(g_0\\) 9.80665 (reference) m/s\u00b2","title":"4. Results Summary Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#5-discussion","text":"","title":"5. Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sources-of-uncertainty","text":"Length measurement resolution: The ruler's precision limits the exact value of \\(L\\) . The half-division rule is used to estimate this uncertainty. Timing uncertainty: Human reaction times and stopwatch precision cause variability in measuring oscillation times. Environmental factors: Air resistance, friction at the pivot, and angle of release (should be <15\u00b0) affect the period. Assumption of small angle: The formula assumes small oscillations to approximate simple harmonic motion; larger angles introduce systematic errors.","title":"Sources of uncertainty:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#impact-of-uncertainties","text":"Timing uncertainty has a larger effect on the uncertainty in \\(g\\) compared to length measurement, as shown by partial derivative magnitudes. Increasing the number of oscillations timed reduces relative timing uncertainty. Improving length measurement precision reduces overall uncertainty, but timing remains dominant.","title":"Impact of uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison-to-standard-g","text":"The measured \\(g = 9.828 \\pm 0.022\\) m/s\u00b2 is close to the standard local gravitational acceleration \\(9.80665\\) m/s\u00b2. The difference may arise from local variations in gravity, experimental errors, or environmental influences.","title":"Comparison to standard \\(g\\):"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}