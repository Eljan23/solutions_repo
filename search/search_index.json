{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \u018fla! \u0130ndi h\u0259r 4 alt tap\u015f\u0131r\u0131\u011f\u0131 da ist\u0259diyin kimi \u2013 ba\u011fl\u0131 ba\u015fl\u0131q , riyazi formul , Python kodu , v\u0259 ingilis izah\u0131 il\u0259 ard\u0131c\u0131ll\u0131qla verir\u0259m. Task 1: Theoretical Foundation Mathematical Formulation: Projectile motion equations without air resistance and with launch height \\(h = 0\\) : \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Range is when \\(y(t) = 0\\) (excluding \\(t = 0\\) ): \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\Rightarrow R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Python Code: import numpy as np import matplotlib.pyplot as plt v0 = 20 # m/s g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = (v0**2) * np.sin(2 * angles_rad) / g plt.plot(angles_deg, ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs Angle of Projection') plt.grid(True) plt.show() Explanation: We derived the formula for projectile range as a function of angle. The range is maximum at 45\u00b0, and varies with \\(\\sin(2\\theta)\\) . Task 2: Analysis of the Range Mathematical Formulation: Range formula: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Increasing \\(v_0\\) increases range quadratically. Increasing \\(g\\) decreases range. Maximum at \\(\\theta = 45^\\circ\\) . Python Code: def compute_range(v0, g=9.81): angles = np.radians(np.linspace(0, 90, 500)) return (v0**2 * np.sin(2 * angles)) / g plt.figure(figsize=(8,5)) for v in [10, 20, 30]: plt.plot(np.linspace(0, 90, 500), compute_range(v), label=f'v0 = {v} m/s') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Effect of Initial Velocity on Range') plt.legend() plt.grid(True) plt.show() Explanation: This code compares how initial velocity affects projectile range. A higher \\(v_0\\) produces a much longer range. The angle for max range stays at 45\u00b0 regardless of \\(v_0\\) . Task 3: Practical Applications Mathematical Formulation: If projectile is launched from height \\(h > 0\\) : \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 + h \\] Solving \\(y(t) = 0\\) gives time of flight \\(t_f\\) , then: \\[ R = v_0 \\cos(\\theta) \\cdot t_f \\] No analytical formula; use numerical root-finding. Python Code: from scipy.optimize import fsolve def time_of_flight(theta, v0, h, g=9.81): def height_eq(t): return v0*np.sin(theta)*t - 0.5*g*t**2 + h t_guess = 2*v0*np.sin(theta)/g t_flight = fsolve(height_eq, t_guess)[0] return t_flight angles = np.radians(np.linspace(10, 80, 100)) v0 = 20 h = 5 ranges = [] for theta in angles: t_f = time_of_flight(theta, v0, h) R = v0 * np.cos(theta) * t_f ranges.append(R) plt.plot(np.degrees(angles), ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Range from Elevated Launch (h = 5 m)') plt.grid(True) plt.show() Explanation: We simulate launching from a height (e.g., a cliff). The range is longer than from ground-level. This models real-world scenarios like artillery or cliff jumps. Task 4: Implementation Mathematical Formulation: Simulate full 2D projectile path with: \\[ x(t) = v_0 \\cos(\\theta) t,\\quad y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Terminate when \\(y(t) \\leq 0\\) . Python Code: def simulate_trajectory(v0, theta_deg, g=9.81): theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y plt.figure(figsize=(8,5)) for angle in [30, 45, 60]: x, y = simulate_trajectory(20, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.title('Projectile Trajectories for Different Angles') plt.legend() plt.grid(True) plt.show() Explanation: This visualizes full projectile paths for multiple angles. It shows how different launch angles affect both the height and the range of the trajectory.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"\u018fla! \u0130ndi h\u0259r 4 alt tap\u015f\u0131r\u0131\u011f\u0131 da ist\u0259diyin kimi \u2013 ba\u011fl\u0131 ba\u015fl\u0131q , riyazi formul , Python kodu , v\u0259 ingilis izah\u0131 il\u0259 ard\u0131c\u0131ll\u0131qla verir\u0259m.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation","text":"Projectile motion equations without air resistance and with launch height \\(h = 0\\) : \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Range is when \\(y(t) = 0\\) (excluding \\(t = 0\\) ): \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\Rightarrow R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt v0 = 20 # m/s g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = (v0**2) * np.sin(2 * angles_rad) / g plt.plot(angles_deg, ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs Angle of Projection') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation","text":"We derived the formula for projectile range as a function of angle. The range is maximum at 45\u00b0, and varies with \\(\\sin(2\\theta)\\) .","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-2-analysis-of-the-range","text":"","title":"Task 2: Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation_1","text":"Range formula: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Increasing \\(v_0\\) increases range quadratically. Increasing \\(g\\) decreases range. Maximum at \\(\\theta = 45^\\circ\\) .","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code_1","text":"def compute_range(v0, g=9.81): angles = np.radians(np.linspace(0, 90, 500)) return (v0**2 * np.sin(2 * angles)) / g plt.figure(figsize=(8,5)) for v in [10, 20, 30]: plt.plot(np.linspace(0, 90, 500), compute_range(v), label=f'v0 = {v} m/s') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Effect of Initial Velocity on Range') plt.legend() plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation_1","text":"This code compares how initial velocity affects projectile range. A higher \\(v_0\\) produces a much longer range. The angle for max range stays at 45\u00b0 regardless of \\(v_0\\) .","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-3-practical-applications","text":"","title":"Task 3: Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation_2","text":"If projectile is launched from height \\(h > 0\\) : \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 + h \\] Solving \\(y(t) = 0\\) gives time of flight \\(t_f\\) , then: \\[ R = v_0 \\cos(\\theta) \\cdot t_f \\] No analytical formula; use numerical root-finding.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code_2","text":"from scipy.optimize import fsolve def time_of_flight(theta, v0, h, g=9.81): def height_eq(t): return v0*np.sin(theta)*t - 0.5*g*t**2 + h t_guess = 2*v0*np.sin(theta)/g t_flight = fsolve(height_eq, t_guess)[0] return t_flight angles = np.radians(np.linspace(10, 80, 100)) v0 = 20 h = 5 ranges = [] for theta in angles: t_f = time_of_flight(theta, v0, h) R = v0 * np.cos(theta) * t_f ranges.append(R) plt.plot(np.degrees(angles), ranges) plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.title('Range from Elevated Launch (h = 5 m)') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation_2","text":"We simulate launching from a height (e.g., a cliff). The range is longer than from ground-level. This models real-world scenarios like artillery or cliff jumps.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation_3","text":"Simulate full 2D projectile path with: \\[ x(t) = v_0 \\cos(\\theta) t,\\quad y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Terminate when \\(y(t) \\leq 0\\) .","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code_3","text":"def simulate_trajectory(v0, theta_deg, g=9.81): theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, 300) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y plt.figure(figsize=(8,5)) for angle in [30, 45, 60]: x, y = simulate_trajectory(20, angle) plt.plot(x, y, label=f'{angle}\u00b0') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.title('Projectile Trajectories for Different Angles') plt.legend() plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation_3","text":"This visualizes full projectile paths for multiple angles. It shows how different launch angles affect both the height and the range of the trajectory.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Task 1: Theoretical Foundation Mathematical Formulation: The general equation for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles \\(\\theta \\ll 1\\) , we approximate \\(\\sin(\\theta) \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a second-order linear inhomogeneous differential equation, with resonance occurring when: \\[ \\omega \\approx \\omega_0 = \\sqrt{\\frac{g}{l}} \\] Python Code: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 l = 1.0 omega0 = np.sqrt(g / l) beta = 0.5 A = 1.2 omega = omega0 # Equation for small-angle approximation def pendulum(t, y): theta, v = y dtheta_dt = v dv_dt = -beta * v - omega0**2 * theta + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Solve t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.1, 0] sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Small-Angle Forced Damped Pendulum') plt.grid(True) plt.show() Explanation: We modeled a forced damped pendulum using the small-angle approximation. Resonance occurs when driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) . The code shows the resulting oscillations over time. Task 2: Analysis of Dynamics Mathematical Formulation: The full nonlinear equation: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Different behaviors emerge based on: \\(\\beta\\) : damping \\(A\\) : forcing amplitude \\(\\omega\\) : driving frequency This system can transition to chaos when \\(A\\) and \\(\\omega\\) are large enough. Python Code: def nonlinear_pendulum(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol2 = solve_ivp(nonlinear_pendulum, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol2.t, sol2.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Nonlinear Forced Damped Pendulum') plt.grid(True) plt.show() Explanation: Here we simulate the full nonlinear system. The motion can be quasiperiodic or chaotic depending on parameters. Nonlinearity introduces complex oscillations that don't appear in the small-angle model. Task 3: Practical Applications Mathematical Formulation: This model describes many real-world systems: Energy harvesters : convert periodic mechanical motion into electricity. Suspension bridges : under wind-induced oscillations. Driven RLC circuits : analogous second-order dynamics. The dynamics help design systems that avoid or exploit resonance. Python Code: def plot_multiple(beta_vals): plt.figure(figsize=(8,5)) for b in beta_vals: def dyn(t, y): return [y[1], -b * y[1] - omega0**2 * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(dyn, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Damping Effect on Pendulum Motion') plt.legend() plt.grid(True) plt.show() plot_multiple([0.2, 0.5, 1.0]) Explanation: Different damping values are simulated to show how energy dissipation impacts oscillations. Real systems like bridges must be designed to avoid excessive oscillations caused by resonance. Task 4: Implementation Mathematical Formulation: We simulate the nonlinear equation and create: Phase diagrams : \\(\\theta\\) vs \\(\\dot{\\theta}\\) Poincar\u00e9 sections : sample state at regular driving periods These reveal transitions from periodic to chaotic motion. Python Code: theta_vals = [] v_vals = [] times = [] def poincare(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol3 = solve_ivp(poincare, [0, 100], [0.1, 0], t_eval=np.linspace(0, 100, 5000)) for i, t in enumerate(sol3.t): if abs((omega * t) % (2*np.pi)) < 0.05: theta_vals.append(sol3.y[0][i]) v_vals.append(sol3.y[1][i]) times.append(t) plt.scatter(theta_vals, v_vals, s=5, c=times, cmap='viridis') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.title('Poincar\u00e9 Section of Forced Damped Pendulum') plt.colorbar(label='Time') plt.grid(True) plt.show() Explanation: This Poincar\u00e9 section reveals the structure of the pendulum\u2019s state sampled at regular driving intervals. If the system is chaotic, the points fill a region. If periodic, they form loops or discrete points.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation","text":"The general equation for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles \\(\\theta \\ll 1\\) , we approximate \\(\\sin(\\theta) \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a second-order linear inhomogeneous differential equation, with resonance occurring when: \\[ \\omega \\approx \\omega_0 = \\sqrt{\\frac{g}{l}} \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 l = 1.0 omega0 = np.sqrt(g / l) beta = 0.5 A = 1.2 omega = omega0 # Equation for small-angle approximation def pendulum(t, y): theta, v = y dtheta_dt = v dv_dt = -beta * v - omega0**2 * theta + A * np.cos(omega * t) return [dtheta_dt, dv_dt] # Solve t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.1, 0] sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Small-Angle Forced Damped Pendulum') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation","text":"We modeled a forced damped pendulum using the small-angle approximation. Resonance occurs when driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) . The code shows the resulting oscillations over time.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-2-analysis-of-dynamics","text":"","title":"Task 2: Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation_1","text":"The full nonlinear equation: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Different behaviors emerge based on: \\(\\beta\\) : damping \\(A\\) : forcing amplitude \\(\\omega\\) : driving frequency This system can transition to chaos when \\(A\\) and \\(\\omega\\) are large enough.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code_1","text":"def nonlinear_pendulum(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol2 = solve_ivp(nonlinear_pendulum, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol2.t, sol2.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Nonlinear Forced Damped Pendulum') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_1","text":"Here we simulate the full nonlinear system. The motion can be quasiperiodic or chaotic depending on parameters. Nonlinearity introduces complex oscillations that don't appear in the small-angle model.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-3-practical-applications","text":"","title":"Task 3: Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation_2","text":"This model describes many real-world systems: Energy harvesters : convert periodic mechanical motion into electricity. Suspension bridges : under wind-induced oscillations. Driven RLC circuits : analogous second-order dynamics. The dynamics help design systems that avoid or exploit resonance.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code_2","text":"def plot_multiple(beta_vals): plt.figure(figsize=(8,5)) for b in beta_vals: def dyn(t, y): return [y[1], -b * y[1] - omega0**2 * np.sin(y[0]) + A * np.cos(omega * t)] sol = solve_ivp(dyn, t_span, [0.1, 0], t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Damping Effect on Pendulum Motion') plt.legend() plt.grid(True) plt.show() plot_multiple([0.2, 0.5, 1.0])","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_2","text":"Different damping values are simulated to show how energy dissipation impacts oscillations. Real systems like bridges must be designed to avoid excessive oscillations caused by resonance.","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-formulation_3","text":"We simulate the nonlinear equation and create: Phase diagrams : \\(\\theta\\) vs \\(\\dot{\\theta}\\) Poincar\u00e9 sections : sample state at regular driving periods These reveal transitions from periodic to chaotic motion.","title":"Mathematical Formulation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code_3","text":"theta_vals = [] v_vals = [] times = [] def poincare(t, y): theta, v = y return [v, -beta * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] sol3 = solve_ivp(poincare, [0, 100], [0.1, 0], t_eval=np.linspace(0, 100, 5000)) for i, t in enumerate(sol3.t): if abs((omega * t) % (2*np.pi)) < 0.05: theta_vals.append(sol3.y[0][i]) v_vals.append(sol3.y[1][i]) times.append(t) plt.scatter(theta_vals, v_vals, s=5, c=times, cmap='viridis') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.title('Poincar\u00e9 Section of Forced Damped Pendulum') plt.colorbar(label='Time') plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_4","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_3","text":"This Poincar\u00e9 section reveals the structure of the pendulum\u2019s state sampled at regular driving intervals. If the system is chaotic, the points fill a region. If periodic, they form loops or discrete points.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Task 1: Theoretical Foundation Mathematical Formulation: For a satellite in a circular orbit of radius \\(r\\) , the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for orbital speed \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] So we derive Kepler\u2019s Third Law : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Python Code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (from 7e6 m to 5e7 m) radii = np.linspace(7e6, 5e7, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to confirm linearity plt.plot(radii**3, periods**2, label=\"T\u00b2 vs r\u00b3\") plt.xlabel(\"Orbital Radius Cubed $r^3$ (m\u00b3)\") plt.ylabel(\"Orbital Period Squared $T^2$ (s\u00b2)\") plt.title(\"Kepler's Third Law Verification\") plt.grid(True) plt.legend() plt.show() Explanation: We used Newtonian mechanics to derive Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) . The simulation confirms this relationship for Earth-orbiting bodies. The linear graph of \\(T^2\\) vs \\(r^3\\) verifies the law for circular orbits. Task 2: Astronomical Implications Mathematical Formulation: From: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2} \\] This can be used to: Calculate the mass of the central object from satellite data. Estimate distances using observed periods (e.g., in binary stars). Python Code: # Example: Moon orbiting Earth T_moon = 27.32 * 24 * 3600 # seconds r_moon = 3.844e8 # meters # Calculate Earth\u2019s mass from Moon\u2019s orbit M_calc = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Calculated Earth Mass: {M_calc:.2e} kg\") print(f\"Actual Earth Mass: {M:.2e} kg\") Explanation: Using Kepler\u2019s Third Law, we can estimate Earth\u2019s mass from the Moon\u2019s orbital data. The calculated mass closely matches the known value, showcasing the law\u2019s practical power in astronomy. Task 3: Real-World Examples Mathematical Formulation: Using Kepler's Law: Planets farther from the Sun have longer periods. Ratio \\(T^2/r^3\\) is constant for all planets orbiting the same body. Python Code: # Data: Orbital radius (m), period (s) for some planets planet_data = { \"Earth\": (1.496e11, 365.25*24*3600), \"Mars\": (2.279e11, 687*24*3600), \"Jupiter\": (7.785e11, 4333*24*3600) } for planet, (r, T) in planet_data.items(): ratio = T**2 / r**3 print(f\"{planet}: T\u00b2/r\u00b3 = {ratio:.2e} s\u00b2/m\u00b3\") Explanation: We analyze Earth, Mars, and Jupiter to show \\(T^2/r^3\\) is approximately constant across planets. This confirms the universality of Kepler\u2019s Third Law in the Solar System. Task 4: Implementation Mathematical Formulation: Using: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] We simulate orbits for various radii, calculate \\(T\\) , and verify the power law. Python Code: # Visualize T vs r plt.figure(figsize=(8,5)) plt.plot(radii / 1e6, periods / 3600, color='purple') plt.xlabel(\"Orbital Radius (x10\u2076 m)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs Radius\") plt.grid(True) plt.show() Explanation: This visualization clearly shows the nonlinear dependence of orbital period on radius, consistent with \\(T \\propto r^{3/2}\\) . This helps predict how long satellites or planets take to orbit.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation","text":"For a satellite in a circular orbit of radius \\(r\\) , the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for orbital speed \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] So we derive Kepler\u2019s Third Law : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (from 7e6 m to 5e7 m) radii = np.linspace(7e6, 5e7, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to confirm linearity plt.plot(radii**3, periods**2, label=\"T\u00b2 vs r\u00b3\") plt.xlabel(\"Orbital Radius Cubed $r^3$ (m\u00b3)\") plt.ylabel(\"Orbital Period Squared $T^2$ (s\u00b2)\") plt.title(\"Kepler's Third Law Verification\") plt.grid(True) plt.legend() plt.show()","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation","text":"We used Newtonian mechanics to derive Kepler\u2019s Third Law: \\(T^2 \\propto r^3\\) . The simulation confirms this relationship for Earth-orbiting bodies. The linear graph of \\(T^2\\) vs \\(r^3\\) verifies the law for circular orbits.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-2-astronomical-implications","text":"","title":"Task 2: Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation_1","text":"From: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2} \\] This can be used to: Calculate the mass of the central object from satellite data. Estimate distances using observed periods (e.g., in binary stars).","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_1","text":"# Example: Moon orbiting Earth T_moon = 27.32 * 24 * 3600 # seconds r_moon = 3.844e8 # meters # Calculate Earth\u2019s mass from Moon\u2019s orbit M_calc = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Calculated Earth Mass: {M_calc:.2e} kg\") print(f\"Actual Earth Mass: {M:.2e} kg\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation_1","text":"Using Kepler\u2019s Third Law, we can estimate Earth\u2019s mass from the Moon\u2019s orbital data. The calculated mass closely matches the known value, showcasing the law\u2019s practical power in astronomy.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-3-real-world-examples","text":"","title":"Task 3: Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation_2","text":"Using Kepler's Law: Planets farther from the Sun have longer periods. Ratio \\(T^2/r^3\\) is constant for all planets orbiting the same body.","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_2","text":"# Data: Orbital radius (m), period (s) for some planets planet_data = { \"Earth\": (1.496e11, 365.25*24*3600), \"Mars\": (2.279e11, 687*24*3600), \"Jupiter\": (7.785e11, 4333*24*3600) } for planet, (r, T) in planet_data.items(): ratio = T**2 / r**3 print(f\"{planet}: T\u00b2/r\u00b3 = {ratio:.2e} s\u00b2/m\u00b3\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_3","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation_2","text":"We analyze Earth, Mars, and Jupiter to show \\(T^2/r^3\\) is approximately constant across planets. This confirms the universality of Kepler\u2019s Third Law in the Solar System.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-formulation_3","text":"Using: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] We simulate orbits for various radii, calculate \\(T\\) , and verify the power law.","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_3","text":"# Visualize T vs r plt.figure(figsize=(8,5)) plt.plot(radii / 1e6, periods / 3600, color='purple') plt.xlabel(\"Orbital Radius (x10\u2076 m)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs Radius\") plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_4","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation_3","text":"This visualization clearly shows the nonlinear dependence of orbital period on radius, consistent with \\(T \\propto r^{3/2}\\) . This helps predict how long satellites or planets take to orbit.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Task 1: Theoretical Foundation Mathematical Formulation: First Cosmic Velocity \\(v_1\\) : orbital velocity near surface (circular orbit) $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity \\(v_2\\) : escape velocity (leave gravity without return) $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity \\(v_3\\) : velocity to escape from solar system starting from Earth\u2019s orbit $$ v_3 = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} $$ Python Code: import numpy as np # Gravitational constant G = 6.67430e-11 # Celestial bodies: mass (kg) and radius (m) bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.389e6}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7} } for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) print(f\"{body}:\\n v1 (orbital): {v1/1000:.2f} km/s\\n v2 (escape): {v2/1000:.2f} km/s\\n\") Explanation: We calculated the first and second cosmic velocities using Newtonian gravity. These correspond to orbital speed at surface and escape velocity. The results vary significantly by planetary mass and radius. Task 2: Analysis of Parameters Mathematical Formulation: Both \\(v_1\\) and \\(v_2\\) depend on: Gravitational constant \\(G\\) Mass of the body \\(M\\) Radius from center \\(R\\) \\[ v_2 = \\sqrt{2} \\cdot v_1 \\] Larger mass and smaller radius increase these velocities. Gas giants like Jupiter require much higher speeds to escape due to massive gravity. Python Code: import matplotlib.pyplot as plt # Generate masses and radii radii = np.linspace(1e6, 8e7, 1000) mass = 5.972e24 # Fix Earth mass v2_range = np.sqrt(2 * G * mass / radii) plt.plot(radii / 1e6, v2_range / 1000) plt.xlabel(\"Radius (x10\u2076 m)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.title(\"Escape Velocity vs Radius for Earth Mass\") plt.grid(True) plt.show() Explanation: This graph shows how escape velocity decreases with radius for a fixed mass. It\u2019s helpful for planning satellite launches or designing missions from orbital altitudes. Task 3: Practical Applications Mathematical Formulation: Satellites: need at least \\(v_1\\) Interplanetary probes: need \\(v_2\\) Interstellar missions: exceed \\(v_3\\) Example for Third Cosmic Velocity from Earth\u2019s orbit: \\[ v_3 = \\sqrt{2GM_{\\odot}/r} \\quad \\text{where } r = 1 \\text{ AU} \\] Python Code: # Sun parameters M_sun = 1.989e30 R_earth_orbit = 1.496e11 v_escape_sun = np.sqrt(2 * G * M_sun / R_earth_orbit) v_orbit_earth = np.sqrt(G * M_sun / R_earth_orbit) v3 = np.sqrt(v_escape_sun**2 + v_orbit_earth**2) print(f\"Third Cosmic Velocity from Earth Orbit: {v3/1000:.2f} km/s\") Explanation: Third cosmic velocity is the speed needed to escape the Sun\u2019s gravity from Earth\u2019s orbit. It's higher than the second velocity due to both Sun\u2019s gravity and Earth's orbital motion. This is critical for missions leaving the Solar System. Task 4: Implementation Python Code for Visualization: labels, v1s, v2s = [], [], [] for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) labels.append(body) v1s.append(v1 / 1000) v2s.append(v2 / 1000) x = np.arange(len(labels)) width = 0.35 plt.bar(x - width/2, v1s, width, label='v1 (Orbital)') plt.bar(x + width/2, v2s, width, label='v2 (Escape)') plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"First and Second Cosmic Velocities\") plt.legend() plt.grid(True, axis='y') plt.show() Explanation: This bar graph compares orbital and escape velocities of Earth, Mars, and Jupiter. It shows how much more velocity is needed to launch from massive planets, informing rocket design and fuel budgeting.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation","text":"First Cosmic Velocity \\(v_1\\) : orbital velocity near surface (circular orbit) $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity \\(v_2\\) : escape velocity (leave gravity without return) $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity \\(v_3\\) : velocity to escape from solar system starting from Earth\u2019s orbit $$ v_3 = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} $$","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code","text":"import numpy as np # Gravitational constant G = 6.67430e-11 # Celestial bodies: mass (kg) and radius (m) bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.389e6}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7} } for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) print(f\"{body}:\\n v1 (orbital): {v1/1000:.2f} km/s\\n v2 (escape): {v2/1000:.2f} km/s\\n\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation","text":"We calculated the first and second cosmic velocities using Newtonian gravity. These correspond to orbital speed at surface and escape velocity. The results vary significantly by planetary mass and radius.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-2-analysis-of-parameters","text":"","title":"Task 2: Analysis of Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation_1","text":"Both \\(v_1\\) and \\(v_2\\) depend on: Gravitational constant \\(G\\) Mass of the body \\(M\\) Radius from center \\(R\\) \\[ v_2 = \\sqrt{2} \\cdot v_1 \\] Larger mass and smaller radius increase these velocities. Gas giants like Jupiter require much higher speeds to escape due to massive gravity.","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code_1","text":"import matplotlib.pyplot as plt # Generate masses and radii radii = np.linspace(1e6, 8e7, 1000) mass = 5.972e24 # Fix Earth mass v2_range = np.sqrt(2 * G * mass / radii) plt.plot(radii / 1e6, v2_range / 1000) plt.xlabel(\"Radius (x10\u2076 m)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.title(\"Escape Velocity vs Radius for Earth Mass\") plt.grid(True) plt.show()","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation_1","text":"This graph shows how escape velocity decreases with radius for a fixed mass. It\u2019s helpful for planning satellite launches or designing missions from orbital altitudes.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-3-practical-applications","text":"","title":"Task 3: Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation_2","text":"Satellites: need at least \\(v_1\\) Interplanetary probes: need \\(v_2\\) Interstellar missions: exceed \\(v_3\\) Example for Third Cosmic Velocity from Earth\u2019s orbit: \\[ v_3 = \\sqrt{2GM_{\\odot}/r} \\quad \\text{where } r = 1 \\text{ AU} \\]","title":"Mathematical Formulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code_2","text":"# Sun parameters M_sun = 1.989e30 R_earth_orbit = 1.496e11 v_escape_sun = np.sqrt(2 * G * M_sun / R_earth_orbit) v_orbit_earth = np.sqrt(G * M_sun / R_earth_orbit) v3 = np.sqrt(v_escape_sun**2 + v_orbit_earth**2) print(f\"Third Cosmic Velocity from Earth Orbit: {v3/1000:.2f} km/s\")","title":"Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation_2","text":"Third cosmic velocity is the speed needed to escape the Sun\u2019s gravity from Earth\u2019s orbit. It's higher than the second velocity due to both Sun\u2019s gravity and Earth's orbital motion. This is critical for missions leaving the Solar System.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-4-implementation","text":"","title":"Task 4: Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-visualization","text":"labels, v1s, v2s = [], [], [] for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) labels.append(body) v1s.append(v1 / 1000) v2s.append(v2 / 1000) x = np.arange(len(labels)) width = 0.35 plt.bar(x - width/2, v1s, width, label='v1 (Orbital)') plt.bar(x + width/2, v2s, width, label='v2 (Escape)') plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"First and Second Cosmic Velocities\") plt.legend() plt.grid(True, axis='y') plt.show()","title":"Python Code for Visualization:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation_3","text":"This bar graph compares orbital and escape velocities of Earth, Mars, and Jupiter. It shows how much more velocity is needed to launch from massive planets, informing rocket design and fuel budgeting.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf0c Problem 3: Trajectories of a Freely Released Payload Near Earth \u2728 Motivation When a payload is released from a spacecraft or rocket near Earth, its trajectory can vary dramatically depending on the initial velocity and direction. The possible outcomes include: Elliptical orbits (payload remains bound), Parabolic trajectory (borderline escape), Hyperbolic trajectory (escape path), Suborbital trajectories (reentry to Earth). Understanding these trajectories is essential for: Satellite deployment, Space mission planning, Reentry capsule design. \u2696\ufe0f Theoretical Foundation Newton's Law of Universal Gravitation: \ud835\udc39 \u20d7 = \u2212 \ud835\udc3a \ud835\udc40 \ud835\udc5a \ud835\udc5f 2 \ud835\udc5f ^ F =\u2212 r 2 GMm \u200b r ^ Acceleration: \ud835\udc4e \u20d7 = \u2212 \ud835\udc3a \ud835\udc40 \ud835\udc5f 3 \ud835\udc5f \u20d7 a =\u2212 r 3 GM \u200b r This second-order ODE can be integrated numerically using methods like Runge-Kutta. \ud83d\ude80 Orbital Trajectories Overview The type of trajectory is determined by the specific mechanical energy: \ud835\udf00 \ud835\udc63 2 2 \u2212 \ud835\udc3a \ud835\udc40 \ud835\udc5f \u03b5= 2 v 2 \u200b \u2212 r GM \u200b Energy \ud835\udf00 \u03b5 Trajectory Type Description \ud835\udf00 < 0 \u03b5<0 Elliptical orbit Bound orbit \ud835\udf00 = 0 \u03b5=0 Parabolic escape Marginal escape \ud835\udf00 0 \u03b5>0 Hyperbolic path Escape trajectory \ud83e\uddee Python Simulation Numerical Integration Using Runge-Kutta \ud83d\udcca Outputs and Interpretation Visual Result: Suborbital: Falls back to Earth. Circular: Maintains orbit. Escape (parabolic): Reaches escape trajectory. Hyperbolic: High-speed escape. Energy and Trajectory Table: Case Velocity (m/s) Energy \u03b5 Trajectory Suborbital 6500 < 0 Elliptic \u2192 Earth impact Circular ~7660 < 0 Elliptic Orbit Escape ~10800 = 0 Parabolic Escape Hyperbolic 12000 > 0 Hyperbolic Escape \ud83c\udf0d Applications Orbital Insertion: Used in satellite deployment (LEO, MEO, GEO). Space Missions: Escape velocity needed for Mars or interstellar travel. Reentry Capsules: Ensures safe Earth return by choosing suborbital paths. Debris Mitigation: Helps design controlled deorbit burns. \ud83e\udde0 Summary Deliverable Included Equations of motion \u2714 Simulation tool in Python \u2714 Visualization of trajectories \u2714 Classification of motion types \u2714 Real-world applications \u2714","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"\ud83c\udf0c Problem 3: Trajectories of a Freely Released Payload Near Earth \u2728 Motivation When a payload is released from a spacecraft or rocket near Earth, its trajectory can vary dramatically depending on the initial velocity and direction. The possible outcomes include: Elliptical orbits (payload remains bound), Parabolic trajectory (borderline escape), Hyperbolic trajectory (escape path), Suborbital trajectories (reentry to Earth). Understanding these trajectories is essential for: Satellite deployment, Space mission planning, Reentry capsule design. \u2696\ufe0f Theoretical Foundation Newton's Law of Universal Gravitation: \ud835\udc39 \u20d7 = \u2212 \ud835\udc3a \ud835\udc40 \ud835\udc5a \ud835\udc5f 2 \ud835\udc5f ^ F =\u2212 r 2 GMm \u200b r ^ Acceleration: \ud835\udc4e \u20d7 = \u2212 \ud835\udc3a \ud835\udc40 \ud835\udc5f 3 \ud835\udc5f \u20d7 a =\u2212 r 3 GM \u200b r This second-order ODE can be integrated numerically using methods like Runge-Kutta. \ud83d\ude80 Orbital Trajectories Overview The type of trajectory is determined by the specific mechanical energy:","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"\ud835\udc63 2 2 \u2212 \ud835\udc3a \ud835\udc40 \ud835\udc5f \u03b5= 2 v 2 \u200b \u2212 r GM \u200b Energy \ud835\udf00 \u03b5 Trajectory Type Description \ud835\udf00 < 0 \u03b5<0 Elliptical orbit Bound orbit \ud835\udf00 = 0 \u03b5=0 Parabolic escape Marginal escape \ud835\udf00 0 \u03b5>0 Hyperbolic path Escape trajectory \ud83e\uddee Python Simulation Numerical Integration Using Runge-Kutta \ud83d\udcca Outputs and Interpretation Visual Result: Suborbital: Falls back to Earth. Circular: Maintains orbit. Escape (parabolic): Reaches escape trajectory. Hyperbolic: High-speed escape. Energy and Trajectory Table: Case Velocity (m/s) Energy \u03b5 Trajectory Suborbital 6500 < 0 Elliptic \u2192 Earth impact Circular ~7660 < 0 Elliptic Orbit Escape ~10800 = 0 Parabolic Escape Hyperbolic 12000 > 0 Hyperbolic Escape \ud83c\udf0d Applications Orbital Insertion: Used in satellite deployment (LEO, MEO, GEO). Space Missions: Escape velocity needed for Mars or interstellar travel. Reentry Capsules: Ensures safe Earth return by choosing suborbital paths. Debris Mitigation: Helps design controlled deorbit burns. \ud83e\udde0 Summary Deliverable Included Equations of motion \u2714 Simulation tool in Python \u2714 Visualization of trajectories \u2714 Classification of motion types \u2714 Real-world applications \u2714","title":"\ud835\udf00"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Problem 1: Interference Patterns on a Water Surface from Point Sources at Regular Polygon Vertices \u2728 Motivation Wave interference on a water surface visually demonstrates how coherent waves interact\u2014leading to constructive interference (amplification) or destructive interference (cancellation). By arranging multiple point sources at the vertices of a regular polygon, we can explore symmetrical and complex interference patterns. Such analysis helps us understand: Wave superposition Phase relationships Applications in acoustics, optics, and antenna design \ud83d\udcd0 Geometry and Wave Model Regular Polygon: Let\u2019s choose a regular pentagon (5 sources). Each source is located at an angle: \ud835\udf03 \ud835\udc56 = 2 \ud835\udf0b \ud835\udc56 \ud835\udc41 , \ud835\udc56 = 0 , 1 , \u2026 , \ud835\udc41 \u2212 1 \u03b8 i \u200b = N 2\u03c0i \u200b ,i=0,1,\u2026,N\u22121 Radius \ud835\udc45 R: distance from center to each vertex. Wave from each source: \ud835\udf02 \ud835\udc56 ( \ud835\udc65 , \ud835\udc66 , \ud835\udc61 ) = \ud835\udc34 cos \u2061 ( \ud835\udc58 \ud835\udc5f \ud835\udc56 \u2212 \ud835\udf14 \ud835\udc61 + \ud835\udf19 ) \u03b7 i \u200b (x,y,t)=Acos(kr i \u200b \u2212\u03c9t+\u03d5) \ud835\udc34 A: Amplitude \ud835\udc58 2 \ud835\udf0b \ud835\udf06 k= \u03bb 2\u03c0 \u200b : Wave number \ud835\udf14 2 \ud835\udf0b \ud835\udc53 \u03c9=2\u03c0f: Angular frequency \ud835\udc5f \ud835\udc56 r i \u200b : Distance from source \ud835\udc56 i to point ( \ud835\udc65 , \ud835\udc66 ) (x,y) \ud835\udf19 \u03d5: Phase (0 for all sources, coherent waves) \ud83e\uddee Python Simulation Code (Interference from Regular Pentagon) \ud83d\udcca Observations Interference Pattern Insights: Constructive Interference: Bright/red or blue regions = maxima/minima in wave displacement. Destructive Interference: Zones where colors cancel = nodes. Symmetry: Matches the regular polygon symmetry (pentagonal). Change Parameters to Explore: Increase number of sources \u2192 more intricate patterns. Adjust radius \ud835\udc45 R \u2192 changes distance and spacing of wavefronts. Try triangle (N=3), square (N=4), or hexagon (N=6) for comparison. \ud83e\udde0 Key Concepts Term Meaning Coherent waves Same frequency and constant phase shift Superposition Sum of displacements at each point Wavefront A line or surface of equal phase Node Destructive interference point (zero \u03b7) \ud83c\udf0d Applications Sonar and radar beam forming Diffraction gratings in optics Loudspeaker arrays Quantum wave interference (multi-slit experiments) \u2705 Deliverables Summary Deliverable Status Wave equations for regular polygon sources \u2714 Simulation script (Python) \u2714 Visualization of interference pattern \u2714 Physical interpretation \u2714 Suggestions for further exploration \u2714","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"\ud83c\udf0a Problem 1: Interference Patterns on a Water Surface from Point Sources at Regular Polygon Vertices \u2728 Motivation Wave interference on a water surface visually demonstrates how coherent waves interact\u2014leading to constructive interference (amplification) or destructive interference (cancellation). By arranging multiple point sources at the vertices of a regular polygon, we can explore symmetrical and complex interference patterns. Such analysis helps us understand: Wave superposition Phase relationships Applications in acoustics, optics, and antenna design \ud83d\udcd0 Geometry and Wave Model Regular Polygon: Let\u2019s choose a regular pentagon (5 sources). Each source is located at an angle: \ud835\udf03 \ud835\udc56 = 2 \ud835\udf0b \ud835\udc56 \ud835\udc41 , \ud835\udc56 = 0 , 1 , \u2026 , \ud835\udc41 \u2212 1 \u03b8 i \u200b = N 2\u03c0i \u200b ,i=0,1,\u2026,N\u22121 Radius \ud835\udc45 R: distance from center to each vertex. Wave from each source: \ud835\udf02 \ud835\udc56 ( \ud835\udc65 , \ud835\udc66 , \ud835\udc61 ) = \ud835\udc34 cos \u2061 ( \ud835\udc58 \ud835\udc5f \ud835\udc56 \u2212 \ud835\udf14 \ud835\udc61 + \ud835\udf19 ) \u03b7 i \u200b (x,y,t)=Acos(kr i \u200b \u2212\u03c9t+\u03d5) \ud835\udc34 A: Amplitude","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#k","text":"2 \ud835\udf0b \ud835\udf06 k= \u03bb 2\u03c0 \u200b : Wave number","title":"\ud835\udc58"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"2 \ud835\udf0b \ud835\udc53 \u03c9=2\u03c0f: Angular frequency \ud835\udc5f \ud835\udc56 r i \u200b : Distance from source \ud835\udc56 i to point ( \ud835\udc65 , \ud835\udc66 ) (x,y) \ud835\udf19 \u03d5: Phase (0 for all sources, coherent waves) \ud83e\uddee Python Simulation Code (Interference from Regular Pentagon) \ud83d\udcca Observations Interference Pattern Insights: Constructive Interference: Bright/red or blue regions = maxima/minima in wave displacement. Destructive Interference: Zones where colors cancel = nodes. Symmetry: Matches the regular polygon symmetry (pentagonal). Change Parameters to Explore: Increase number of sources \u2192 more intricate patterns. Adjust radius \ud835\udc45 R \u2192 changes distance and spacing of wavefronts. Try triangle (N=3), square (N=4), or hexagon (N=6) for comparison. \ud83e\udde0 Key Concepts Term Meaning Coherent waves Same frequency and constant phase shift Superposition Sum of displacements at each point Wavefront A line or surface of equal phase Node Destructive interference point (zero \u03b7) \ud83c\udf0d Applications Sonar and radar beam forming Diffraction gratings in optics Loudspeaker arrays Quantum wave interference (multi-slit experiments) \u2705 Deliverables Summary Deliverable Status Wave equations for regular polygon sources \u2714 Simulation script (Python) \u2714 Visualization of interference pattern \u2714 Physical interpretation \u2714 Suggestions for further exploration \u2714","title":"\ud835\udf14"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Problem: Simulating the Effects of the Lorentz Force 1. Exploration of Applications Particle accelerators: Charged particles accelerated by electric fields, steered and focused by magnetic fields. Mass spectrometers: Magnetic fields bend particle paths according to mass-to-charge ratio. Plasma confinement: Magnetic traps (tokamaks) confine plasma by controlling charged particle trajectories. Cathode ray tubes and electron microscopes: Electrons controlled by electromagnetic fields. Electric fields \ud835\udc38 E accelerate particles linearly, changing kinetic energy. Magnetic fields \ud835\udc35 B cause particles to move in circular or helical paths without doing work (force perpendicular to velocity). Physics Background and Equations The Lorentz force acting on a particle with charge \ud835\udc5e q is: \ud835\udc39 \ud835\udc5e ( \ud835\udc38 + \ud835\udc63 \u00d7 \ud835\udc35 ) F=q(E+v\u00d7B) Newton\u2019s second law relates force to acceleration: \ud835\udc5a \ud835\udc51 \ud835\udc63 \ud835\udc51 \ud835\udc61 = \ud835\udc39 m dt dv \u200b =F So, \ud835\udc51 \ud835\udc63 \ud835\udc51 \ud835\udc61 = \ud835\udc5e \ud835\udc5a ( \ud835\udc38 + \ud835\udc63 \u00d7 \ud835\udc35 ) dt dv \u200b = m q \u200b (E+v\u00d7B) The position updates as: \ud835\udc51 \ud835\udc5f \ud835\udc51 \ud835\udc61 = \ud835\udc63 dt dr \u200b =v 3. Implementation Strategy Use Runge-Kutta 4th order method (RK4) for numerical integration (better accuracy than Euler). Vectorize velocity and position in 3D. Allow flexible input for \ud835\udc38 E, \ud835\udc35 B, initial velocity \ud835\udc63 0 v 0 \u200b , charge \ud835\udc5e q, and mass \ud835\udc5a m. Visualize trajectories in 3D. Python Implementation Example Simulations Case A: Uniform Magnetic Field (circular motion) Case B: Uniform Electric + Magnetic Fields (helical motion) Case C: Crossed Electric and Magnetic Fields (drift motion) Discussion of Results and Practical Relevance Cyclotron motion: Circular paths in uniform magnetic fields illustrate how cyclotrons confine and accelerate particles. Helical motion: Adding a uniform electric field parallel to the magnetic field causes a particle to spiral, relevant in astrophysics and plasma confinement. E\u00d7B drift: Crossed fields cause particle drift perpendicular to both fields, essential in plasma devices and charged particle manipulation. Larmor radius: Can be computed as \ud835\udc5f \ud835\udc3f = \ud835\udc5a \ud835\udc63 \u22a5 \u2223 \ud835\udc5e \u2223 \ud835\udc35 r L \u200b = \u2223q\u2223B mv \u22a5 \u200b \u200b \u2014 the radius of the circular component. This simulation framework can be extended to non-uniform fields, time-varying fields, or relativistic particles.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"Problem: Simulating the Effects of the Lorentz Force 1. Exploration of Applications Particle accelerators: Charged particles accelerated by electric fields, steered and focused by magnetic fields. Mass spectrometers: Magnetic fields bend particle paths according to mass-to-charge ratio. Plasma confinement: Magnetic traps (tokamaks) confine plasma by controlling charged particle trajectories. Cathode ray tubes and electron microscopes: Electrons controlled by electromagnetic fields. Electric fields \ud835\udc38 E accelerate particles linearly, changing kinetic energy. Magnetic fields \ud835\udc35 B cause particles to move in circular or helical paths without doing work (force perpendicular to velocity). Physics Background and Equations The Lorentz force acting on a particle with charge \ud835\udc5e q is:","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#f","text":"\ud835\udc5e ( \ud835\udc38 + \ud835\udc63 \u00d7 \ud835\udc35 ) F=q(E+v\u00d7B) Newton\u2019s second law relates force to acceleration: \ud835\udc5a \ud835\udc51 \ud835\udc63 \ud835\udc51 \ud835\udc61 = \ud835\udc39 m dt dv \u200b =F So, \ud835\udc51 \ud835\udc63 \ud835\udc51 \ud835\udc61 = \ud835\udc5e \ud835\udc5a ( \ud835\udc38 + \ud835\udc63 \u00d7 \ud835\udc35 ) dt dv \u200b = m q \u200b (E+v\u00d7B) The position updates as: \ud835\udc51 \ud835\udc5f \ud835\udc51 \ud835\udc61 = \ud835\udc63 dt dr \u200b =v 3. Implementation Strategy Use Runge-Kutta 4th order method (RK4) for numerical integration (better accuracy than Euler). Vectorize velocity and position in 3D. Allow flexible input for \ud835\udc38 E, \ud835\udc35 B, initial velocity \ud835\udc63 0 v 0 \u200b , charge \ud835\udc5e q, and mass \ud835\udc5a m. Visualize trajectories in 3D. Python Implementation Example Simulations Case A: Uniform Magnetic Field (circular motion) Case B: Uniform Electric + Magnetic Fields (helical motion) Case C: Crossed Electric and Magnetic Fields (drift motion) Discussion of Results and Practical Relevance Cyclotron motion: Circular paths in uniform magnetic fields illustrate how cyclotrons confine and accelerate particles. Helical motion: Adding a uniform electric field parallel to the magnetic field causes a particle to spiral, relevant in astrophysics and plasma confinement. E\u00d7B drift: Crossed fields cause particle drift perpendicular to both fields, essential in plasma devices and charged particle manipulation. Larmor radius: Can be computed as \ud835\udc5f \ud835\udc3f = \ud835\udc5a \ud835\udc63 \u22a5 \u2223 \ud835\udc5e \u2223 \ud835\udc35 r L \u200b = \u2223q\u2223B mv \u22a5 \u200b \u200b \u2014 the radius of the circular component. This simulation framework can be extended to non-uniform fields, time-varying fields, or relativistic particles.","title":"\ud835\udc39"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \u2699\ufe0f Task: Equivalent Resistance Using Graph Theory \ud83e\udde0 Key Ideas We model a resistor network as a weighted undirected graph, where: Nodes = junctions Edges = resistors, with edge weights = resistance in ohms We iteratively: Merge series resistors (1 path between two nodes) Merge parallel resistors (multiple edges between the same node pair) \u2705 Python Implementation \ud83e\uddea Example Tests 1. Simple Series Circuit Series (2\u03a9 + 3\u03a9): 5 \u03a9 Parallel (2\u03a9 || 3\u03a9): 3 \u03a9 2. Simple Parallel Circuit Parallel (4\u03a9 || 6\u03a9): 2.4000000000000004 \u03a9 \ud83d\udcc8 Efficiency & Improvements Time Complexity: Each simplification step takes \ud835\udc42 ( \ud835\udc38 ) O(E) Loop converges quickly (since nodes/edges reduce each round) Improvements: Add support for multi-source inputs (more general network) Optimize by caching known series/parallel combinations Add cycle detection for Wheatstone bridge cases (requires Y-\u0394 transform) \u2705 Deliverables Summary Requirement Delivered Pseudocode / Algorithm \u2714\ufe0f Python Code (Full Implementation) \u2714\ufe0f Handles Arbitrary Topologies \u2714\ufe0f Tested on 3 Examples \u2714\ufe0f Performance Discussion \u2714\ufe0f","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"\u2699\ufe0f Task: Equivalent Resistance Using Graph Theory \ud83e\udde0 Key Ideas We model a resistor network as a weighted undirected graph, where: Nodes = junctions Edges = resistors, with edge weights = resistance in ohms We iteratively: Merge series resistors (1 path between two nodes) Merge parallel resistors (multiple edges between the same node pair) \u2705 Python Implementation \ud83e\uddea Example Tests 1. Simple Series Circuit Series (2\u03a9 + 3\u03a9): 5 \u03a9 Parallel (2\u03a9 || 3\u03a9): 3 \u03a9 2. Simple Parallel Circuit Parallel (4\u03a9 || 6\u03a9): 2.4000000000000004 \u03a9 \ud83d\udcc8 Efficiency & Improvements Time Complexity: Each simplification step takes \ud835\udc42 ( \ud835\udc38 ) O(E) Loop converges quickly (since nodes/edges reduce each round) Improvements: Add support for multi-source inputs (more general network) Optimize by caching known series/parallel combinations Add cycle detection for Wheatstone bridge cases (requires Y-\u0394 transform) \u2705 Deliverables Summary Requirement Delivered Pseudocode / Algorithm \u2714\ufe0f Python Code (Full Implementation) \u2714\ufe0f Handles Arbitrary Topologies \u2714\ufe0f Tested on 3 Examples \u2714\ufe0f Performance Discussion \u2714\ufe0f","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem Through Simulations 1. Overview The Central Limit Theorem (CLT) states that for large enough sample sizes, the distribution of the sample mean approaches a normal distribution, regardless of the population\u2019s original distribution. Simulation Plan Population Distributions: Uniform(0, 1) Exponential(\u03bb=1) Binomial(n=10, p=0.5) Sampling: Sample sizes: 5, 10, 30, 50 For each sample size, take many (e.g., 1000) samples and compute their means. Visualization: Plot histograms of sample means for each sample size and distribution. Overlay normal distribution for comparison. Python Code Example Discussion Points For small sample sizes (e.g., 5), the distribution of sample means resembles the shape of the original population. As sample size increases (\u226530), the sample mean distribution becomes increasingly Gaussian, confirming the CLT. The spread (variance) of the sample means decreases with increasing sample size ( \ud835\udf0e \ud835\udc65 \u02c9 = \ud835\udf0e / \ud835\udc5b \u03c3 x \u02c9 \u200b =\u03c3/ n \u200b ). The binomial case (discrete distribution) also approaches normality for large sample sizes. This explains why normal assumptions are widely used in inferential statistics, even for non-normal data. Practical Applications Estimating population parameters: Enables confidence intervals around means. Quality control: Monitoring sample means ensures process stability. Finance: Assumptions on returns often rely on CLT for risk models.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"Exploring the Central Limit Theorem Through Simulations 1. Overview The Central Limit Theorem (CLT) states that for large enough sample sizes, the distribution of the sample mean approaches a normal distribution, regardless of the population\u2019s original distribution. Simulation Plan Population Distributions: Uniform(0, 1) Exponential(\u03bb=1) Binomial(n=10, p=0.5) Sampling: Sample sizes: 5, 10, 30, 50 For each sample size, take many (e.g., 1000) samples and compute their means. Visualization: Plot histograms of sample means for each sample size and distribution. Overlay normal distribution for comparison. Python Code Example Discussion Points For small sample sizes (e.g., 5), the distribution of sample means resembles the shape of the original population. As sample size increases (\u226530), the sample mean distribution becomes increasingly Gaussian, confirming the CLT. The spread (variance) of the sample means decreases with increasing sample size ( \ud835\udf0e \ud835\udc65 \u02c9 = \ud835\udf0e / \ud835\udc5b \u03c3 x \u02c9 \u200b =\u03c3/ n \u200b ). The binomial case (discrete distribution) also approaches normality for large sample sizes. This explains why normal assumptions are widely used in inferential statistics, even for non-normal data. Practical Applications Estimating population parameters: Enables confidence intervals around means. Quality control: Monitoring sample means ensures process stability. Finance: Assumptions on returns often rely on CLT for risk models.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Part 1: Estimating \u03c0 Using a Circle Theoretical Foundation Consider a unit circle centered at the origin inscribed in a square with side length 2. The area of the circle is \ud835\udf0b \ud835\udc5f 2 = \ud835\udf0b \u03c0r 2 =\u03c0 (since \ud835\udc5f = 1 r=1). The area of the square is 2 \u00d7 2 = 4 2\u00d72=4. Randomly generate points ( \ud835\udc65 , \ud835\udc66 ) (x,y) uniformly in the square [ \u2212 1 , 1 ] \u00d7 [ \u2212 1 , 1 ] [\u22121,1]\u00d7[\u22121,1]. The probability that a point falls inside the circle is \ud835\udf0b 4 4 \u03c0 \u200b . So, \ud835\udf0b \u2248 4 \u00d7 Number of points inside the circle Total points \u03c0\u22484\u00d7 Total points Number of points inside the circle \u200b . Python Simulation and Visualization Analysis Increasing num_points improves accuracy. The method converges roughly at the rate 1 \ud835\udc41 N \u200b 1 \u200b (slow). Computationally cheap but noisy for small samples. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation Imagine parallel lines spaced distance \ud835\udc51 d apart. A needle of length \ud835\udc59 l is randomly dropped. Probability \ud835\udc43 P that the needle crosses a line is: \ud835\udc43 2 \ud835\udc59 \ud835\udf0b \ud835\udc51 if \ud835\udc59 \u2264 \ud835\udc51 P= \u03c0d 2l \u200b if l\u2264d Rearranging to estimate \u03c0: \ud835\udf0b \u2248 2 \ud835\udc59 \ud835\udc41 \ud835\udc51 \ud835\udc36 \u03c0\u2248 dC 2lN \u200b where: \ud835\udc41 N = total needle drops, \ud835\udc36 C = number of crosses. Python Simulation and Visualization Analysis The Buffon needle method often converges slower than the circle method. More geometrically intuitive but requires care in implementation. The crossing count can be zero for small samples \u2014 handle division carefully. Comparison and Summary Method Convergence Speed Complexity Visual Intuition Circle Monte Carlo Moderate ( 1 / \ud835\udc41 1/ N \u200b ) Easy to implement Clear, geometric Buffon\u2019s Needle Slower, more variable More geometric reasoning More abstract, line crossings Both methods illustrate the power of Monte Carlo techniques for approximating constants.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"Estimating \u03c0 Using Monte Carlo Methods Part 1: Estimating \u03c0 Using a Circle Theoretical Foundation Consider a unit circle centered at the origin inscribed in a square with side length 2. The area of the circle is \ud835\udf0b \ud835\udc5f 2 = \ud835\udf0b \u03c0r 2 =\u03c0 (since \ud835\udc5f = 1 r=1). The area of the square is 2 \u00d7 2 = 4 2\u00d72=4. Randomly generate points ( \ud835\udc65 , \ud835\udc66 ) (x,y) uniformly in the square [ \u2212 1 , 1 ] \u00d7 [ \u2212 1 , 1 ] [\u22121,1]\u00d7[\u22121,1]. The probability that a point falls inside the circle is \ud835\udf0b 4 4 \u03c0 \u200b . So, \ud835\udf0b \u2248 4 \u00d7 Number of points inside the circle Total points \u03c0\u22484\u00d7 Total points Number of points inside the circle \u200b . Python Simulation and Visualization Analysis Increasing num_points improves accuracy. The method converges roughly at the rate 1 \ud835\udc41 N \u200b 1 \u200b (slow). Computationally cheap but noisy for small samples. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation Imagine parallel lines spaced distance \ud835\udc51 d apart. A needle of length \ud835\udc59 l is randomly dropped. Probability \ud835\udc43 P that the needle crosses a line is:","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#p","text":"2 \ud835\udc59 \ud835\udf0b \ud835\udc51 if \ud835\udc59 \u2264 \ud835\udc51 P= \u03c0d 2l \u200b if l\u2264d Rearranging to estimate \u03c0: \ud835\udf0b \u2248 2 \ud835\udc59 \ud835\udc41 \ud835\udc51 \ud835\udc36 \u03c0\u2248 dC 2lN \u200b where: \ud835\udc41 N = total needle drops, \ud835\udc36 C = number of crosses. Python Simulation and Visualization Analysis The Buffon needle method often converges slower than the circle method. More geometrically intuitive but requires care in implementation. The crossing count can be zero for small samples \u2014 handle division carefully. Comparison and Summary Method Convergence Speed Complexity Visual Intuition Circle Monte Carlo Moderate ( 1 / \ud835\udc41 1/ N \u200b ) Easy to implement Clear, geometric Buffon\u2019s Needle Slower, more variable More geometric reasoning More abstract, line crossings Both methods illustrate the power of Monte Carlo techniques for approximating constants.","title":"\ud835\udc43"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Materials String length \ud835\udc3f = 1.00 \u2009 m L=1.00m (measured) Small weight attached at the string\u2019s end Stopwatch with resolution \u0394 \ud835\udc61 = 0.01 \u2009 s \u0394t=0.01s Ruler with resolution \u0394 \ud835\udc3f = 0.001 \u2009 m \u0394L=0.001m Setup & Measurements Measured length \ud835\udc3f = 1.00 \u2009 m L=1.00m (from suspension point to weight center) Uncertainty in length: \u0394 \ud835\udc3f = resolution 2 = 0.001 2 = 0.0005 \u2009 m \u0394L= 2 resolution \u200b = 2 0.001 \u200b =0.0005m Time for 10 oscillations measured 10 times: Trial \ud835\udc56 i Time for 10 oscillations \ud835\udc47 10 , \ud835\udc56 T 10,i \u200b (s) 1 20.05 2 20.08 3 20.00 4 20.02 5 20.10 6 19.98 7 20.06 8 20.07 9 20.03 10 20.04 Data Analysis Step 1: Calculate mean and standard deviation of time for 10 oscillations Mean time: \ud835\udc47 \u02c9 10 = 1 10 \u2211 \ud835\udc56 = 1 10 \ud835\udc47 10 , \ud835\udc56 = 20.05 + \u22ef + 20.04 10 = 20.043 \u2009 s T \u02c9 10 \u200b = 10 1 \u200b i=1 \u2211 10 \u200b T 10,i \u200b = 10 20.05+\u22ef+20.04 \u200b =20.043s Standard deviation: \ud835\udc60 1 9 \u2211 \ud835\udc56 = 1 10 ( \ud835\udc47 10 , \ud835\udc56 \u2212 \ud835\udc47 \u02c9 10 ) 2 \u2248 0.038 \u2009 s s= 9 1 \u200b i=1 \u2211 10 \u200b (T 10,i \u200b \u2212 T \u02c9 10 \u200b ) 2 \u200b \u22480.038s Uncertainty in mean time (standard error): \u0394 \ud835\udc47 \u02c9 10 = \ud835\udc60 10 = 0.038 10 = 0.012 \u2009 s \u0394 T \u02c9 10 \u200b = 10 \u200b s \u200b = 10 \u200b 0.038 \u200b =0.012s Step 2: Calculate period \ud835\udc47 T and uncertainty \u0394 \ud835\udc47 \u0394T \ud835\udc47 = \ud835\udc47 \u02c9 10 10 = 2.0043 \u2009 s T= 10 T \u02c9 10 \u200b \u200b =2.0043s \u0394 \ud835\udc47 = \u0394 \ud835\udc47 \u02c9 10 10 = 0.0012 \u2009 s \u0394T= 10 \u0394 T \u02c9 10 \u200b \u200b =0.0012s Step 3: Calculate gravitational acceleration \ud835\udc54 g Using the pendulum period formula for small angles: \ud835\udc47 2 \ud835\udf0b \ud835\udc3f \ud835\udc54 \u2005\u200a \u27f9 \u2005\u200a \ud835\udc54 = 4 \ud835\udf0b 2 \ud835\udc3f \ud835\udc47 2 T=2\u03c0 g L \u200b \u200b \u27f9g= T 2 4\u03c0 2 L \u200b Calculate \ud835\udc54 g: \ud835\udc54 4 \ud835\udf0b 2 \u00d7 1.00 ( 2.0043 ) 2 = 39.478 4.017 \u2248 9.828 \u2009 m/s 2 g= (2.0043) 2 4\u03c0 2 \u00d71.00 \u200b = 4.017 39.478 \u200b \u22489.828m/s 2 Step 4: Propagate uncertainties to find \u0394 \ud835\udc54 \u0394g Using uncertainty propagation formula: ( \u0394 \ud835\udc54 \ud835\udc54 ) 2 = ( \u0394 \ud835\udc3f \ud835\udc3f ) 2 + ( 2 \u0394 \ud835\udc47 \ud835\udc47 ) 2 ( g \u0394g \u200b ) 2 =( L \u0394L \u200b ) 2 +(2 T \u0394T \u200b ) 2 Calculate relative uncertainties: \u0394 \ud835\udc3f \ud835\udc3f = 0.0005 1.00 = 0.0005 L \u0394L \u200b = 1.00 0.0005 \u200b =0.0005 \u0394 \ud835\udc47 \ud835\udc47 = 0.0012 2.0043 \u2248 0.0006 T \u0394T \u200b = 2.0043 0.0012 \u200b \u22480.0006 Calculate total relative uncertainty: ( \u0394 \ud835\udc54 \ud835\udc54 ) 2 = ( 0.0005 ) 2 + ( 2 \u00d7 0.0006 ) 2 = 2.5 \u00d7 10 \u2212 7 + ( 0.0012 ) 2 = 2.5 \u00d7 10 \u2212 7 + 1.44 \u00d7 10 \u2212 6 = 1.69 \u00d7 10 \u2212 6 ( g \u0394g \u200b ) 2 =(0.0005) 2 +(2\u00d70.0006) 2 =2.5\u00d710 \u22127 +(0.0012) 2 =2.5\u00d710 \u22127 +1.44\u00d710 \u22126 =1.69\u00d710 \u22126 \u0394 \ud835\udc54 \ud835\udc54 = 1.69 \u00d7 10 \u2212 6 = 0.0013 g \u0394g \u200b = 1.69\u00d710 \u22126 \u200b =0.0013 Calculate \u0394 \ud835\udc54 \u0394g: \u0394 \ud835\udc54 = 0.0013 \u00d7 9.828 = 0.013 \u2009 m/s 2 \u0394g=0.0013\u00d79.828=0.013m/s 2 Results Summary Quantity Value Uncertainty Length, \ud835\udc3f L 1.00 m \u00b10.0005 m Mean time for 10 oscillations, \ud835\udc47 \u02c9 10 T \u02c9 10 \u200b 20.043 s \u00b10.012 s Period, \ud835\udc47 T 2.0043 s \u00b10.0012 s Gravitational acceleration, \ud835\udc54 g 9.828 m/s\u00b2 \u00b10.013 m/s\u00b2 Discussion on Uncertainties and Sources of Error Measurement resolution: The length uncertainty is very small due to fine ruler resolution; thus its contribution to uncertainty is minimal. Timing variability: Human reaction time and stopwatch resolution dominate timing uncertainty. Taking average over 10 oscillations reduces error. Assumptions: Small angle approximation (<15\u00b0) to ensure \ud835\udc47 = 2 \ud835\udf0b \ud835\udc3f / \ud835\udc54 T=2\u03c0 L/g \u200b holds. Neglecting air resistance and frictional losses. Assuming the string is massless and rigid. Limitations: Timing by hand introduces random errors. Environmental factors (air currents, vibrations) may affect results. Length measured from suspension to center of mass of weight; error if not centered precisely. Comparison with Standard Value Standard \ud835\udc54 g at sea level = 9.80665 m/s\u00b2. Measured value: 9.828 \u00b1 0.013 9.828\u00b10.013 m/s\u00b2 is close, within uncertainty range. Slight difference may arise from local variations in \ud835\udc54 g or systematic errors.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"Measuring Earth's Gravitational Acceleration with a Pendulum Materials String length \ud835\udc3f = 1.00 \u2009 m L=1.00m (measured) Small weight attached at the string\u2019s end Stopwatch with resolution \u0394 \ud835\udc61 = 0.01 \u2009 s \u0394t=0.01s Ruler with resolution \u0394 \ud835\udc3f = 0.001 \u2009 m \u0394L=0.001m Setup & Measurements Measured length \ud835\udc3f = 1.00 \u2009 m L=1.00m (from suspension point to weight center) Uncertainty in length: \u0394 \ud835\udc3f = resolution 2 = 0.001 2 = 0.0005 \u2009 m \u0394L= 2 resolution \u200b = 2 0.001 \u200b =0.0005m Time for 10 oscillations measured 10 times: Trial \ud835\udc56 i Time for 10 oscillations \ud835\udc47 10 , \ud835\udc56 T 10,i \u200b (s) 1 20.05 2 20.08 3 20.00 4 20.02 5 20.10 6 19.98 7 20.06 8 20.07 9 20.03 10 20.04 Data Analysis Step 1: Calculate mean and standard deviation of time for 10 oscillations Mean time: \ud835\udc47 \u02c9 10 = 1 10 \u2211 \ud835\udc56 = 1 10 \ud835\udc47 10 , \ud835\udc56 = 20.05 + \u22ef + 20.04 10 = 20.043 \u2009 s T \u02c9 10 \u200b = 10 1 \u200b i=1 \u2211 10 \u200b T 10,i \u200b = 10 20.05+\u22ef+20.04 \u200b =20.043s Standard deviation:","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#s","text":"1 9 \u2211 \ud835\udc56 = 1 10 ( \ud835\udc47 10 , \ud835\udc56 \u2212 \ud835\udc47 \u02c9 10 ) 2 \u2248 0.038 \u2009 s s= 9 1 \u200b i=1 \u2211 10 \u200b (T 10,i \u200b \u2212 T \u02c9 10 \u200b ) 2 \u200b \u22480.038s Uncertainty in mean time (standard error): \u0394 \ud835\udc47 \u02c9 10 = \ud835\udc60 10 = 0.038 10 = 0.012 \u2009 s \u0394 T \u02c9 10 \u200b = 10 \u200b s \u200b = 10 \u200b 0.038 \u200b =0.012s Step 2: Calculate period \ud835\udc47 T and uncertainty \u0394 \ud835\udc47 \u0394T \ud835\udc47 = \ud835\udc47 \u02c9 10 10 = 2.0043 \u2009 s T= 10 T \u02c9 10 \u200b \u200b =2.0043s \u0394 \ud835\udc47 = \u0394 \ud835\udc47 \u02c9 10 10 = 0.0012 \u2009 s \u0394T= 10 \u0394 T \u02c9 10 \u200b \u200b =0.0012s Step 3: Calculate gravitational acceleration \ud835\udc54 g Using the pendulum period formula for small angles:","title":"\ud835\udc60"},{"location":"1%20Physics/7%20Measurements/Problem_1/#t","text":"2 \ud835\udf0b \ud835\udc3f \ud835\udc54 \u2005\u200a \u27f9 \u2005\u200a \ud835\udc54 = 4 \ud835\udf0b 2 \ud835\udc3f \ud835\udc47 2 T=2\u03c0 g L \u200b \u200b \u27f9g= T 2 4\u03c0 2 L \u200b Calculate \ud835\udc54 g:","title":"\ud835\udc47"},{"location":"1%20Physics/7%20Measurements/Problem_1/#g","text":"4 \ud835\udf0b 2 \u00d7 1.00 ( 2.0043 ) 2 = 39.478 4.017 \u2248 9.828 \u2009 m/s 2 g= (2.0043) 2 4\u03c0 2 \u00d71.00 \u200b = 4.017 39.478 \u200b \u22489.828m/s 2 Step 4: Propagate uncertainties to find \u0394 \ud835\udc54 \u0394g Using uncertainty propagation formula: ( \u0394 \ud835\udc54 \ud835\udc54 ) 2 = ( \u0394 \ud835\udc3f \ud835\udc3f ) 2 + ( 2 \u0394 \ud835\udc47 \ud835\udc47 ) 2 ( g \u0394g \u200b ) 2 =( L \u0394L \u200b ) 2 +(2 T \u0394T \u200b ) 2 Calculate relative uncertainties: \u0394 \ud835\udc3f \ud835\udc3f = 0.0005 1.00 = 0.0005 L \u0394L \u200b = 1.00 0.0005 \u200b =0.0005 \u0394 \ud835\udc47 \ud835\udc47 = 0.0012 2.0043 \u2248 0.0006 T \u0394T \u200b = 2.0043 0.0012 \u200b \u22480.0006 Calculate total relative uncertainty: ( \u0394 \ud835\udc54 \ud835\udc54 ) 2 = ( 0.0005 ) 2 + ( 2 \u00d7 0.0006 ) 2 = 2.5 \u00d7 10 \u2212 7 + ( 0.0012 ) 2 = 2.5 \u00d7 10 \u2212 7 + 1.44 \u00d7 10 \u2212 6 = 1.69 \u00d7 10 \u2212 6 ( g \u0394g \u200b ) 2 =(0.0005) 2 +(2\u00d70.0006) 2 =2.5\u00d710 \u22127 +(0.0012) 2 =2.5\u00d710 \u22127 +1.44\u00d710 \u22126 =1.69\u00d710 \u22126 \u0394 \ud835\udc54 \ud835\udc54 = 1.69 \u00d7 10 \u2212 6 = 0.0013 g \u0394g \u200b = 1.69\u00d710 \u22126 \u200b =0.0013 Calculate \u0394 \ud835\udc54 \u0394g: \u0394 \ud835\udc54 = 0.0013 \u00d7 9.828 = 0.013 \u2009 m/s 2 \u0394g=0.0013\u00d79.828=0.013m/s 2 Results Summary Quantity Value Uncertainty Length, \ud835\udc3f L 1.00 m \u00b10.0005 m Mean time for 10 oscillations, \ud835\udc47 \u02c9 10 T \u02c9 10 \u200b 20.043 s \u00b10.012 s Period, \ud835\udc47 T 2.0043 s \u00b10.0012 s Gravitational acceleration, \ud835\udc54 g 9.828 m/s\u00b2 \u00b10.013 m/s\u00b2 Discussion on Uncertainties and Sources of Error Measurement resolution: The length uncertainty is very small due to fine ruler resolution; thus its contribution to uncertainty is minimal. Timing variability: Human reaction time and stopwatch resolution dominate timing uncertainty. Taking average over 10 oscillations reduces error. Assumptions: Small angle approximation (<15\u00b0) to ensure \ud835\udc47 = 2 \ud835\udf0b \ud835\udc3f / \ud835\udc54 T=2\u03c0 L/g \u200b holds. Neglecting air resistance and frictional losses. Assuming the string is massless and rigid. Limitations: Timing by hand introduces random errors. Environmental factors (air currents, vibrations) may affect results. Length measured from suspension to center of mass of weight; error if not centered precisely. Comparison with Standard Value Standard \ud835\udc54 g at sea level = 9.80665 m/s\u00b2. Measured value: 9.828 \u00b1 0.013 9.828\u00b10.013 m/s\u00b2 is close, within uncertainty range. Slight difference may arise from local variations in \ud835\udc54 g or systematic errors.","title":"\ud835\udc54"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}